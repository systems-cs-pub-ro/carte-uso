% Author: Răzvan Deaconescu
% Editors: Sergiu Weisz, Răzvan Deaconescu
% Reviewers: Ruxandra Caba, Adriana Szekeres, Mihai Maruseac, Giorgiana Vlăsceanu

\chapter{Utilizatori}
\label{ch:user}

Sistemul de operare oferă resurse pe care utilizatorii să le poată folosi.
În mod obișnuit, utilizatorii creează procese (aplicații) care folosesc resursele sistemului (procesor, memorie, I/O) pentru a realiza o activitate.
Utilizatorii stochează și transferă date în/din sistemul de calcul, de exemplu folosind sistemul de fișiere sau rețeaua.

Accesul la un sistem de calcul se realizează prin intermediul unui \textbf{cont de utilizator} (\textit{user account}).
Un utilizator fizic (o persoană) folosește un cont de utilizator pentru a se identifica în sistem și pentru a folosi resurse cu permisiunile aferente acelui cont de utilizator.
În ceea ce urmează vom folosi, în general, termenul de utilizator ca fiind un cont de utilizator pe un sistem de calcul.

Sistemele de operare moderne sunt în general multi-utilizator (\textit{multi-user}), adică permit existența mai multor conturi de utilizator pe un sistem și rularea simultană a mai multor procese aparținând diferiților utilizatori.
Mai mulți utilizatori pot simultan deschide shelluri locale și rula comenzi pe un sistem prin conexiuni de rețea la sistem, precum folosind SSH\abbrev{SSH}{Secure Shell}, despre care vom discuta în \labelindexref{Capitolul}{ch:sec}.
Un cont de utilizator este separat de alt cont astfel că procesele unui utilizator sunt separate/izolate de procesele altuia, la fel și resursele folosite de procese (precum fișierele).

Informațiile despre conturile de utilizatori sunt utile nu doar utilizatorilor avansați, ci și utilizatorilor obișnuiți.
Deși utilizatorul obișnuit are în general un singur cont pe sistemul propriu, informațiile despre conturile de utilizator îi sunt necesare pentru a înțelege ce acțiuni poate executa pe sistemul de operare, pentru ce acțiuni are nevoie de accesul la un cont privilegiat.
De asemenea, poate să creeze la nevoie un cont pentru un prieten sau o rudă pe un sistem al său.
Sau se poate autentifica pe sistemul altcuiva și va trebui să aibă grijă ce informații lasă pe acel sistem.
Pentru un utilizator cu permisiuni speciale (\textit{power user}) sau un administrator, informațiile despre și operațiile cu utilizatori sunt esențiale pentru a asigura accesul mai multor utilizatori fizici la un sistem dat, pentru a se asigura de separarea resurselor între aceștia și între procesele acestora și, în general, pentru a garanta securitatea sistemului.

Din punctul de vedere al sistemului de operare, un cont de utilizator este reprezentat de obicei sub forma unui nume de utilizator (\textit{username}).
Acesta este un șir de caractere cu care este identificat utilizatorul.
Pentru a permite accesul în sistem, acestui nume de utilizator i se asociază o formă de autentificare, precum parolă sau autentificare biometrică.
Dacă utilizatorul fizic furnizează în interfața de acces la sistem un nume de utilizator valid și forma de autentificare corectă, i se permite accesul în sistem.

Până acum am prezentat conturi de utilizator de sistem, adică acele conturi care permit crearea de procese și dețin resurse precum fișiere.
Există și conturi de utilizatori de aplicații, precum conturile de utilizatori de aplicații web.
Aceste conturi permit accesul la resurse care sunt gestionate de aplicație, nu de sistemul de operare.
De asemenea, aceste conturi nu permit crearea de procese sau accesul la resursele sistemului;
permit doar accesul gestionat de aplicație la resursele aplicației.

Indiferent de tipul de cont de utilizator (de sistem sau de aplicație) principiul de folosire este același: se folosește un nume de utilizator și o formă de autentificare pentru a permite accesul acestuia la resursele sistemului sau aplicației.
Toate numele de utilizator și formele de autentificare valide sunt menținute într-o bază de date.
Când un utilizator fizic transmite aceste date, sistemul sau aplicația le verifică dacă sunt prezente în baza de date;
în caz afirmativ se oferă accesul la resurse.
Acest mod de folosire este descris în \labelindexref{Figura}{fig:user:db-access}.

\begin{figure}[htbp]
  \centering
  \def\svgwidth{0.9\columnwidth}
  \includesvg{chapters/05-user/img/acces-bd.svg}
  \caption{Bază de date de access}
  \label{fig:user:db-access}
\end{figure}

În continuare ne vom referi în general la conturile de utilizator de sistem, cu precizarea că multe concepte se aplică și la conturile de utilizator de aplicație.

\section{Utilizatori de sistem}
\label{sec:user:system-users}

Așa cum am precizat mai sus, conturile de utilizator de sistem sunt folosite pentru a obține acces la resursele gestionate de sistemul de operare.
Conturile de utilizator permit obținerea unui shell și rularea de comenzi care creează procese.

De obicei, un sistem de operare oferă un prompt grafic sau text de autentificare unde vor fi completate numele de utilizator și apoi, uzual, parola.

În momentul autentificării unui utilizator de sistem, acesta are acces complet la o parte din sistemul de fișiere numită \textbf{directorul home al utilizatorului}, reprezentând directorul personal al acestuia.
Fiecare sistem de operare are, în general, un astfel de director pentru utilizatorul de sistem (\file{/home/student} pe Linux, \file{C:\textbackslash{}Users\textbackslash{}student} pe Windows, \file{/Users/student} pe macOS).
După autentificare, utilizatorul poate crea procese care apoi accesează fișiere sau alte resurse ale utilizatorului.

\subsection{Permisiuni și privilegii}
\label{sec:user:permissions}

Odată autentificat în sistem, un utilizator are anumite permisiuni de folosire a sistemului.
De exemplu, un utilizator obișnuit poate crea fișiere doar în directorul său home, dar nu poate instala pachete.
Un alt utilizator poate avea permisiunea de a instala pachete.
Sistemul de operare, pe baza unor configurări, permite unui utilizator anumite acțiuni.

În unele sisteme și aplicații există noțiunea de rol.
Un utilizator poate avea un rol care îi atribuie anumite permisiuni.
De exemplu, rolul de \texttt{Administrator} înseamnă, în general, într-o instalare de platformă precum Moodle\footnote{\url{http://www.moodle.org}}, permisiuni complete în cadrul platformei;
un rol de \texttt{Profesor} înseamnă controlul conținutului cursurilor;
un rol de \texttt{Student} înseamnă posibilitatea accesării conținutului.

În general, sistemele oferă anumite permisiuni utilizatorilor.
Structurarea acestor permisiuni este esențială pentru asigurarea securității sistemului.
Dacă un utilizator are mai multe permisiuni decât are nevoie, acesta va putea abuza sau exploata sistemul.
Dacă un atacator din exterior obține permisiunile unui utilizator (impersonează utilizatorul), pagubele pe care le provoacă vor fi proporționale cu permisiunile utilizatorului.

Din punctul de vedere al conceptelor de securitate, utilizatorul este un \textbf{agent} iar resursele puse la dispoziție de sistem sunt \textbf{obiecte}.
\textbf{Politica de securitate} (\textit{security policy}) a sistemului precizează permisiunile și dictează ce agenți au acces la ce obiecte.
În acest context, apar adesea termenii de \textbf{permisiune} și \textbf{privilegiu}.

\begin{definition}{Permisiuni și privilegii}
  În general, spunem că permisiunile sunt informații aferente obiectului care stabilesc ce agenți pot face tipuri de acțiuni, în vreme ce privilegiile sunt certificate aferente agentului care stabilesc ce acțiuni poate acesta întreprinde.
  Mai multe informații găsiți în \labelindexref{Capitolul}{ch:sec}.
\end{definition}

În sistemele de operare de uz general (Linux/Unix, Windows, macOS) există, în general, \textbf{utilizatori obișnuiți} (neprivilegiați) și \textbf{utilizatori privilegiați}.

\begin{definition}{Utilizatori privilegiați și neprivilegiați}
  Utilizatorii neprivilegiați au acces complet la o parte din sistemul de fișiere (directorul home) și pot crea procese care folosesc aceste resurse.
  Utilizatorii privilegiați pot face acțiuni care afectează starea globală a sistemului: instalare de pachete, adăugare/ștergere de utilizatori, repornirea sistemului, configurarea datei sistemului, schimbarea permisiunilor sistemului, configurarea rețelei etc.
\end{definition}

În general, există un utilizator al sistemului care are permisiuni complete.
De obicei ne referim la acest utilizator ca \textit{superuser}.
Pe sistemele Linux/Unix este numit \texttt{root}, în vreme ce pe sistemele Windows este numit \texttt{Administrator}.
În multe situații, pentru realizarea unei operații privilegiate, se accesează contul de \textit{superuser}.

\section{Utilizatorul administrativ (superuser)}
\label{sec:user:superuser}

Utilizatorul administrativ, \textit{superuserul}, deține controlul complet al sistemului.
Toate operațiile privilegiate, inaccesibile unui utilizator obișnuit neprivilegiat, sunt permise acestuia.
Un utilizator obișnuit va accesa acest cont special (dacă știe parola sau forma de autentificare a acestuia) pentru a realiza o operație privilegiată.

Faptul că superuserul are acces complet la sistem îl face foarte periculos de folosit.
Dacă un atacator obține acces neautorizat la contul de superuser, atunci sistemul este compromis.
La fel, dacă rulăm greșit o comandă privilegiată, aceasta poate afecta iremediabil sistemul.

\begin{note}[Comanda rm -fr /]
  Comanda \cmd{rm -fr /} este celebră pentru că poate fi folosită pentru a șterge tot sistemul de fișiere.
  Dacă este folosită de contul de \texttt{root} această comandă șterge conținutul sistemului de fișiere începând de la directorul rădăcină (\texttt{/}).
  Aveți grijă în folosire acestei comenzi și, ori de câte ori ștergeți un fișier, aveți grijă ce argumente transmiteți comenzii \cmd{rm}.
\end{note}

De aceea, sistemele de operare moderne pun la dispoziția utilizatorul metode de realizare de acțiuni privilegiate care să nu necesite accesarea directă a contului privliegiat.
Astfel că, în folosirea superuserului, există următoarele recomandări de folosire:

\begin{itemize}
  \item Să fie folosit contul doar când este absolută nevoie, pentru operații privilegiate.
    Nu vă autentificați ca superuser pe interfața grafică.
  \item Să fie o parolă / formă de autentificare cât mai greu de accesat în mod neautorizat.
  \item Să fie evitată folosirea superuser-ului când există forme alternative de executare de acțiuni privilegiate.
\end{itemize}

Sistemele de operare moderne oferă opțiuni alternative de executare a acțiunilor privilegiate.
În Linux/Unix se poate folosi \cmd{sudo}, bitul setuid, capabilități;
le vom prezenta în \labelindexref{Secțiunea}{sec:user:altroot}.

În Windows, începând cu Windows Vista se folosește \textit{User Account Control} (UAC\abbrev{UAC}{User Acount Control}), prezentat în \labelindexref{Figura}{fig:user:uac}.
\textit{User Account Control} este o tehnologie care oferă un prompt care trebuie confirmat ori de câte ori se dorește realizarea unei acțiuni privilegiate.
Doar utilizatorilor configurați specific li se permite rularea de acțiuni privilegiate prin User Account Control.

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=0.6\textwidth]{chapters/05-user/img/uac.png}
  \caption{User Account Control}
  \label{fig:user:uac}
\end{figure}

\subsection{Utilizatorul administrativ în Linux (root)}
\label{sec:user:root}

Utilizatorul administrativ în Linux este numit \texttt{root}.
Utilizatorul \texttt{root} are acces complet la resursele sistemului și poate face orice operații.
În general, accesarea contului de \texttt{root} este evidențiată în linia de comandă prin prezența simbolului \texttt{\#} (\textit{diez}) în cadrul promptului ca în \labelindexref{Listing}{lst:user:prompt-types}.

\begin{screen}[caption={Prompt neprivilegiat și privilegiat (root)},label={lst:user:prompt-types}]
student@uso:~$ sudo su
[sudo] password for student:
root@uso:/home/student#
\end{screen}

În secvența de mai sus, utilizatorul inițial este \texttt{student}, iar promptul său este marcat de simbolul \texttt{\$} (\textit{dolar}) la finalul promptului.
Atunci când folosim comanda \texttt{sudo su} și după ce introducem parola utilizatorului \texttt{student}, obținem un shell privilegiat, marcat de simbolul \texttt{\#} (\textit{diez}) la finalul promptului.

Accesarea unui cont (inclusiv a contului \texttt{root}) se poate face în două moduri:

\begin{itemize}
  \item autentificarea în sistem cu acel cont (la un prompt de login în linia de comandă sau în interfața grafică)
  \item schimbarea utilizatorului curent în linia de comandă prin folosirea comenzii \cmd{su} (\textit{substitute user})
\end{itemize}

În general, nu este recomandată autentificarea în sistem folosind contul de \texttt{root}.
Orice aplicație care va fi lansată din acest cont va avea acces complet asupra resurselor sistemului, devenind astfel o posibilă zonă de atac a acestuia.
Este recomandat să folosiți comanda \cmd{su} pentru schimbarea temporară a utilizatorului și obținerea unui shell de \texttt{root}, folosirea comenzilor privilegiate și apoi revenirea în consola utilizatorului neprivilegiat folosind comanda \cmd{exit}, așa cum este ilustrat în \labelindexref{Listing}{lst:user:root-access}.

\begin{screen}[caption={Accesarea contului root},label={lst:user:root-access}]
student@uso:~$ su
Password:
root@uso:/home/student# apt install deluge
[...]
root@uso:/home/student# exit
exit
student@uso:~$
\end{screen}

În \labelindexref{Listing}{lst:user:root-access} am folosind comanda \texttt{su} urmată de introducerea parolei utilizatorului \texttt{root} pentru a accesa contul privilegiat.
Acum putem executa acțiuni privilegiate, precum instalarea pachetului \texttt{deluge}.
La final folosim comanda \texttt{exit} pentru a încheia sesiunea curentă privilegiată și a reveni la un shell de utilizator neprivilegiat (\texttt{student}).

\subsection{Utilitarul su}
\label{sec:user:su}

Utilitarul \cmd{su} este folosit pentru schimbarea utilizatorului, nu neapărat în \texttt{root}.
Dacă \cmd{su} nu primește nici un argument sau primește ca argument \texttt{root}, va schimba utilizatorul în \texttt{root}.
Altfel, va schimba în utilizatorul primit ca parametru.
Așa cum apare în \labelindexref{Listing}{lst:user:su}, la rularea comenzii \cmd{su} se cere parola noului utilizator;
fără introducerea parolei acelui utilizator nu se poate schimba utilizatorul.

\begin{screen}[caption={Schimbarea contului de utilizator folosind comanda su},label={lst:user:su}]
student@uso:~$ su teacher
Password:
teacher@uso:/home/student$ exit
student@uso:~$ su - teacher
Password:
teacher@uso:~$ logout
student@uso:~$ su -l teacher
Password:
teacher@uso:~$ logout
student@uso:~$ su -l teacher -c whoami
Password:
teacher
\end{screen}

Liniile 4 și 7 din \labelindexref{Listing}{lst:user:su} prezintă o formă uzuală de rulare a comenzii \cmd{su} cu opțiunea \texttt{-l} sau \texttt{-};
această formă schimbă mediul de
lucru al viitoarei comenzi, incluzând directorul home.
După cum se poate observa, există o diferență între linia \texttt{3} și liniile \texttt{6} și \texttt{9}, care folosesc opțiunile \texttt{-} și \texttt{-l}: după schimbarea utilizatorului se schimbă și directorul curent în directorul home al noului utilizator.
Acest lucru se observă în promptul expus de shell.

Utilitarul \cmd{su} permite rularea unei comenzi fără a deschide un shell prin intermediul opțiunii \texttt{-c}, ca în liniile \texttt{10--12} din \labelindexref{Listing}{lst:user:su}.
În felul acesta se rulează direct comanda primită ca argument și apoi se revine la shellul utilizatorului curent, fără a se deschide un shell al noului utilizator.

\subsection{Alternative la root în Linux}
\label{sec:user:altroot}

Așa cum am precizat anterior, utilizatorul \texttt{root} deține controlul întregului sistem.
Dacă un atacator obține acces neautorizat la contul \texttt{root}, sistemul va fi compromis.
Pe de altă parte, privilegiile pe care le deține utilizatorul \texttt{root} sunt necesare pentru administrarea sau funcționarea sistemului, precum configurarea unei interfețe de rețea.
De aceea sistemele de operare moderne oferă opțiuni de granularizare a privilegiilor.
În Linux există câteva astfel de opțiuni printre care amintim bitul setuid, capabilități și utilitarul \cmd{sudo}.

Bitul setuid (\textit{set-user-id-on-execution}) este un bit asociat unui fișier executabil.
Atunci când executăm acel fișier procesul nou creat nu va aparține utilizatorului care a rulat comanda, ci utilizatorului care deține fișierul, în mod obișnuit utilizatorul \texttt{root}.
\labelindexref{Listing}{lst:user:setuid} conține un exemplu de folosire a bitului \texttt{setuid}.
Observăm în permisiunile fișierelo \texttt{/bin/ping}, \texttt{/bin/su}, \texttt{/usr/bin/sudo} prezența literei \texttt{s}, însemnând bitul setuid.

\begin{screen}[caption={Bitul set-user-id-on-execution (setuid)},label={lst:user:setuid}]
student@uso:~$ ls -l /bin/ping
-rwsr-xr-x 1 root root 64424 Mar 10  2017 /bin/ping
student@uso:~$ ls -l /bin/su
-rwsr-xr-x 1 root root 44664 Jan 25  2018 /bin/su
student@uso:~$ ls -l /usr/bin/sudo
-rwsr-xr-x 1 root root 149080 Jan 31  2020 /usr/bin/sudo
\end{screen}

Prezența bitului \texttt{setuid} pe un executabil deținut de \texttt{root} (de exemplu \cmd{passwd}, \cmd{su}, \cmd{sudo}) înseamnă că acele comenzi pot fi rulate de orice utilizator pentru a crea procese privilegiate.
Vom explica în \labelindexref{Secțiunea}{sec:user:auth} de ce aceste comenzi sunt privilegiate.

Bitul \texttt{setuid} are dezavantajul că procesul nou creat rulează cu privilegii complete de \texttt{root}.
Dacă acel proces este exploatat, atacatorul va deține un proces cu permisiuni de \texttt{root} și sistemul va fi compromis.
De aceea, pe Linux există un alt mecanism numit \textbf{capabilități}.
Capabilitățile sunt un concept de bază în sisteme de operare însemnând atașarea unui privilegiu unui agent (unui obiect).
De exemplu, pe sistemele Linux moderne, executabilul aferent utilitarului ping are atașată capabilitatea \texttt{cap\_net\_raw}.
Această capabilitate înseamnă că procesele create din executabilul \cmd{ping} vor avea privilegiul de a crea resurse privilegiate necesare utilitarului \cmd{ping}.

Spre deosebire de bitul de setuid, capabilitățile sunt granulare.
Privilegiile aferente contului \texttt{root} sunt separate în capabilități.
Un proces are atașate, la nevoie, doar capabilitățile de care are nevoie;
dacă acel proces este exploatat atunci acțiunile posibile ale atacatorului sunt limitate la ce privilegii oferă capabilitățile, nu la toate privilegiile contului de \texttt{root}.

Exemple de capabilități pe Linux sunt:

\begin{itemize}
  \item \texttt{cap\_net\_raw}: permite folosirea de sockeți speciali (numiți \textit{raw})
  \item \texttt{cap\_net\_admin}: permite configurarea rețelei
  \item \texttt{cap\_fowner}: permite configurare de permisiuni pe orice fișier
  \item \texttt{cap\_kill}: permite transmiterea de semnale către orice procese
\end{itemize}

\begin{note}[Documentație despre capabilități]
  Suportul de capabilități este o componentă avansată a sistemului de operare, care permite dezvoltatorilor de aplicații configurarea de privilegii granulare.
  Pentru mai multe detalii, urmăriți pagina de manual, folosind comanda \cmd{man 7 capabilities}.
\end{note}

\subsubsection{Utilitarul sudo}
\label{sec:user:sudo}

Bitul \texttt{setuid} și capabilitățile sunt mecanisme care oferă privilegii unor executabile și a proceselor pornite din acestea sau, în cazul capabilităților, și mai granular, unor procese.
Nu permit ușor atașarea de privilegii unui utilizator sau configurarea personalizată (\textit{custom}) a acțiunilor care pot fi executate de acel utilizator.
Pentru aceasta, soluția folosită pe sistemele Unix este \cmd{sudo}.

\cmd{sudo} este un utilitar care permite rularea unor comenzi în numele altui utilizator, în general \texttt{root}.
\cmd{sudo} are o configurare granulară și permite precizarea explicită a ce comenzi să fie rulate.
Spre deosebire de utilitarul \cmd{su}, la rularea utilitarului \cmd{sudo} nu este nevoie de cunoașterea parolei noului utilizator, ci a utilizatorului curent.

În mod tipic, când rulăm \cmd{sudo}, îl succedăm cu comanda pe care vrem să o executăm ca \texttt{root}, ca în exemplele din \labelindexref{Listing}{lst:user:sudo}.
Liniile \texttt{1} și \texttt{3} arată rularea unei comenzi în mod privilegiat prin prefixarea acesteia cu \texttt{sudo}.
Adesea dorim obținerea unui shell de \texttt{root} pentru a rula mai multe comenzi privilegiate.
Pentru aceasta rulăm tipic una dintre cele două comenzi de pe liniile \texttt{4--8} din \labelindexref{Listing}{lst:user:sudo}: \texttt{sudo su} sau \texttt{sudo bash}.

\begin{screen}[caption={Folosirea sudo},label={lst:user:sudo}]
student@uso:~$ sudo apt install inkscape
[...]
student@uso:~$ sudo adduser dean
student@uso:~$ sudo su
root@uso:/home/student# exit
student@uso:~$ sudo bash
root@uso:~# exit
student@uso:~$
\end{screen}

Utilitarul \cmd{sudo} permite unui utilizator să ruleze comenzi ca \texttt{root} (sau ca alt utilizator) printr-o configurație din fișierul de configurare \file{/etc/sudoers}.
\labelindexref{Listing}{lst:user:sudoers} conține secvențe din fișierul de configurare \file{/etc/sudoers}.
De exemplu, conform liniei de configurare \texttt{2} utilizatorul \texttt{student} poate rula comenzi ca \texttt{root}.

\begin{screen}[caption={Secvențe din fișierul /etc/sudoers},label={lst:user:sudoers}]
# User privilege specification
student ALL=(ALL:ALL) ALL
teacher ALL=(ALL:ALL) /bin/cat

# Allow members of group admin to execute any command.
%admin  ALL=(ALL) ALL

# Allow members of group sudo to execute any command.
%sudo        ALL=(ALL) ALL
\end{screen}

În mod obișnuit, fișierul \file{/etc/sudoers} are linii de configurare care permit utilizatorilor din grupul \texttt{admin} sau grupul \cmd{sudo} să poată rula comenzi ca \texttt{root}, precum liniile \texttt{5} și \texttt{9} din \labelindexref{Listing}{lst:user:sudoers}.

În această situație, dacă dorim ca un utilizator să poată rula comenzi ca \texttt{root} îl adăugăm în grupul admin sau în grupul \cmd{sudo}, nu este nevoie de editarea fișierului \file{/etc/sudoers}.

\begin{note}[Folosirea contului de root]
  E important când e folosit \texttt{root} și când se obține consolă de \texttt{root} și ce utilizatori au acces la \cmd{sudo}.
  Avem grijă când acordăm unui utilizator \textit{permisiuni de sudo}, adică posibilitatea de a rula comenzi ca \texttt{root}, lucru care poate duce la compromiterea sistemului.
\end{note}

\cmd{sudo} permite configurări mai avansate în fișierul \file{/etc/sudoers};
de exemplu linia de configurare \texttt{3} din \labelindexref{Listing}{lst:user:sudoers} permite utilizatorului \texttt{teacher} rularea doar a comenzii \texttt{cat} ca \texttt{root}, permițând vizualizarea tuturor fișierelor din sistem, ca în \labelindexref{Listing}{lst:user:sudo-command}.
Utilizatorul \texttt{teacher} nu poate vizualiza conținutul fișierului \file{/etc/sudoers} (folosind comanda \cmd{cat}).
Dar poate dacă prefixează cu \texttt{sudo} comanda de afișare.

\begin{screen}[caption={Rularea unei comenzi privilegiate cu sudo},label={lst:user:sudo-command}]
teacher@uso:~$ cat /etc/sudoers
cat: /etc/sudoers: Permission denied
teacher@uso:~$ sudo cat /etc/sudoers
[sudo] password for teacher:
#
# This file MUST be edited with the 'visudo' command as root.
\end{screen}

Fișierul \file{/etc/sudoers} este un fișier important în sistem și de aceea există mai multe restricții și convenții pentru accesarea acestuia.
Astfel, deoarece configurația sa afectează întreg sistemul de operare, editarea fișierului este permisă numai utilizatorului privilegiat.
De asemenea, pentru a preveni editarea eronată (ce poate duce sistemul într-o stare de eroare imposibil de rezolvat), se recomandă folosirea comenzii \cmd{visudo} pentru editare.
Pentru editarea sa, fie rulăm comanda \cmd{visudo} ca \texttt{root}, fie comanda \cmd{sudo visudo}.

\begin{note}[Folosire /etc/sudoers]
  Fișierul \file{/etc/sudoers} permite configurări avansate.
  Puteți parcurge pagina de manual \cmd{man sudoers} sau resursele din Internet\footnote{\url{https://www.digitalocean.com/community/tutorials/how-to-edit-the-sudoers-file-on-ubuntu-and-centos}}.
\end{note}

\paragraph{sudo și redirectare}

O situație frecventă este să redirectăm rezultatul rulării unei comenzi într-un fișier privilegiat (la care nu avem de obicei acces).
De exemplu, dacă dorim să activăm rutarea pe un sistem Linux, vom rula, ca \texttt{root}, comanda:

\begin{screen}
student@uso:~$ echo 1 > /proc/sys/net/ipv4/ip_forward
\end{screen}

În momentul în care folosim un utilizator neprivilegiat dar care poate folosi \cmd{sudo}, am fi tentați să încercăm să rulăm comanda:

\begin{screen}
student@uso:~$ sudo echo 1 > /proc/sys/net/ipv4/ip_forward
\end{screen}

Acest lucru însă nu funcționează pentru că, deși comanda \cmd{echo 1} rulează ca \texttt{root}, comanda \cmd{sudo}, al cărei output este redirectat, rulează ca utilizator neprivilegiat.
Adică redirectarea cu operatorul \texttt{$>$} are loc pentru comanda \cmd{sudo}, rulată de utilizator neprivilegiat, și nu va reuși.

Soluția la această situație este să nu folosim redirectare ci să folosim o comandă care primește ca argument acel fișier, iar comanda să ruleze privilegiat ca \cmd{sudo}.
Adică soluția este folosirea comenzii \cmd{tee}, ca mai jos:

\begin{screen}
student@uso:~$ echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward
\end{screen}

În forma de mai sus comanda \cmd{tee} este rulată ca \texttt{root} prin intermediul utilitarului \cmd{sudo}.
Comanda scrie informația primită la intrarea standard (adică \texttt{1}) în fișierul primit ca argument (\file{/proc/sys/netc/ipv4/ip\_forward}) în mod privilegiat.

\begin{note}[Folosire \cmd{tee} pentru a scrie într-un fișier privilegiat]
  Atunci când dorim să scriem într-un fișier privilegiat fără a accesa o consolă de \texttt{root}, folosim comanda tee cu \cmd{sudo}.
  Comanda \cmd{tee} are și opțiunea \texttt{-a} pentru adăuga informație la sfârșitul fișierului (\textit{append});
  în mod obișnuit, comanda suprascrie conținutul fișierului primit ca argument.
\end{note}

\section{Operații cu utilizatori}
\label{sec:user:operations}

În sistemul de operare un utilizator este reprezentat de procesele și resursele acestuia.
Procesele și resursele (de exemplu fișierele) sunt marcate ca aparținând utilizatorului.

Pentru un utilizator fizic (o persoană), un utilizator este identificat printr-un nume de utilizator (\textit{username});
atunci când ne autentificăm, pentru acces folosim numele de utilizator.
La nivelul sistemului de operare, însă, un utilizator este identificat printr-un număr, numit în mod uzual \textit{user identifier} sau \textbf{UID}, similar cum un proces este identificat printr-un \textit{process identifier} (PID).

Procesele și fișierele unui utilizator au în atributele acestora câmpul UID.
Pentru procese, acest câmp oferă informații despre ce operații asupra resurselor sistemului de operare pot fi executate de proces, în timp ce câmpul UID al fișierelor identifică utilizatorul care le deține.
În \labelindexref{Listting}{lst:user:print-uid} afișăm UID-ul proceselor folosind comanda \cmd{ps} și listăm UID-ul unui fișier folosind comand \cmd{stat}.
Observăm că UID-ul utilizatorului \texttt{student} este \texttt{1000}: liniile \texttt{3}, \texttt{4} și \texttt{9}.

\begin{screen}[caption={Afișare UID pentru procese și fișiere},label={lst:user:print-uid}]
student@uso:~$ ps -o pid,ppid,uid,user,cmd
  PID  PPID   UID USER     CMD
24104 24103  1000 student  -bash
24610 24104  1000 student  ps -o pid,ppid,uid,user,cmd
student@uso:~$ stat vm-actions-log.txt
  File: vm-actions-log.txt
  Size: 4827      	Blocks: 16         IO Block: 4096   regular file
Device: 801h/2049d	Inode: 659107      Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/ student)   Gid: ( 1000/ student)
Access: 2020-08-08 16:32:44.086193999 +0300
Modify: 2018-08-21 14:37:44.316527432 +0300
Change: 2018-08-21 14:37:44.320529432 +0300
 Birth: -
\end{screen}

De obicei, un proces poate avea acces la o resursă dacă UID-ul procesului este marcat în cadrul resursei ca având acces.

\subsection{Atribute ale utilizatorilor. Informații despre utilizatori}
\label{sec:user:attributes}

Un utilizator are atribute care îi permit identificarea în sistem, autentificarea și accesul la resurse.
Așa cum am precizat mai sus, cele mai importante două atribute sunt numele de utilizator (\textit{username}) și identificatorul de utilizator (\textit{user identifier}, UID).

Un utilizator de sistem are acces la un director home (un subdirector în sistemul de fișiere unde are acces complet).
Pentru utilizatorul \texttt{student} acesta este, în mod uzual, \file{/home/student} (pe Linux), \file{/Users/student} (pe macOS) sau \file{C:\textbackslash{}Users\textbackslash{}student} (pe Windows).

Pentru autentificare, un utilizator are asociată o parolă sau o altă formă de autentificare.
Aceasta trebuie furnizată la un prompt de login (interfață în linia de comandă sau grafică) pentru a fi permis accesul în sistem în contul acelui utilizator.

Pe sistemele Unix, un utilizator are asociat un shell de autentificare (\textit{login shell}).
Este programul care este rulat în momentul autentificării utilizatorului pe un sistem;
programul este, de obicei, un shell în linia de comandă.

Pentru gestiunea mai flexibilă a accesului la resurse, \textbf{utilizatorii sunt grupați}.
Un utilizator face parte din unul sau mai multe grupuri.
Astfel că, un administrator care dorește ca mai mulți utilizatori să aibă acces la o anumită resursă va crea un grup, va adăuga utilizatorii la acel grup și va oferi grupului permisiuni asupra resursei respective.
Un grup poate conține 0 sau mai mulți utilizatori, iar un utilizator poate aparține unui sau mai multor grupuri, așa cum este indicat în \labelindexref{Figura}{fig:user:multi-user}.

\begin{figure}[htbp]
  \centering
  \def\svgwidth{\columnwidth}
  \includesvg{chapters/05-user/img/multi-user.svg}
  \caption{Asocierea utilizatori la grupuri}
  \label{fig:user:multi-user}
\end{figure}

De exemplu, în Windows, există grupul \texttt{Administrators}.
Un utilizator care este parte din grupul \texttt{Administrators} are acces complet la sistem.

Aceste atribute sunt definite în fișiere de configurare sau de tip bază de date.
Aceste atribute pot fi, de obicei, vizualizate de orice utilizator, dar modificate doar de un utilizator privilegiat.
Mai multe informații prezentăm în \labelindexref{Secțiunea}{sec:user:attributes}

\subsection{Obținerea de informații despre utilizatori}
\label{sec:user:user:info}

Informațiile despre utilizatori (nume de utilizator, identificator de utilizator, director home) pot fi obținute folosind interfețele grafice aferente unui sistem de operare sau distribuții sau folosind utilitare în linia de comandă.

În Windows, pentru obținerea de informații despre utilizatori folosim în mod obișnuit interfața grafică: \textit{Control Panel $\rightarrow$ User Accounts $\rightarrow$ User Accounts}.

\subsubsection{Obținerea de informații despre utilizatori în Linux}
\label{sec:user:linux-user-info}

În Linux, informațiile despre utilizatori sunt stocate în fișiere de configurare dedicate.
În scenarii de administrare mai complexe (care nu fac subiectul acestei cărți), aceste informații sunt stocate într-o baza de date.
Fișierele de configurare în care sunt reținute informații despre utilizatori sunt indicate în \labelindexref{Tabelul}{table:user:info-files}.

\begin{table}[!htb]
  \begin{center}
    \begin{tabular}{ p{0.18\textwidth} p{0.22\textwidth} p{0.55\textwidth} }
      \toprule
        \textbf{Fișier} &
        \textbf{Rol} &
        \textbf{Informații} \\
      \midrule
        \file{/etc/passwd} &
        informații utilizatori &
        nume de utilizator, UID, director home, shell de login, GID \\
      \midrule
        \file{/etc/shadow} &
        parole utilizatori &
        nume de utilizator, parolă criptată, informații expirare parolă \\
      \midrule
        \file{/etc/group} &
        informații grupuri &
        nume grup, GID, utilizatori aferenți \\
      \bottomrule
    \end{tabular}
  \end{center}
  \caption{Informații despre utilizatori}
  \label{table:user:info-files}
\end{table}

Fișierele de configurare au formă tabelară cu coloane: fiecare linie este o intrare în tabel iar fiecare coloană este un atribut al acelei intrări.
Mai jos sunt prezentate câteva linii din fiecare fișier de configurare și explicațiile pentru rolul acestora.
Detalii despre fișierele \file{/etc/passwd} și \file{/etc/shadow} prezentăm în \labelindexref{Secțiunea}{sec:user:auth}.

Putem obține informații despre utilizatori direct din fișierele de configurare de mai sus, așa cum facem în \labelindexref{Listing}{lst:user:config-files}.

\begin{screen}[caption={Investigarea fișierelor de configurare pentru utilizatori},label={lst:user:config-files}]
student@uso:~$ grep student /etc/passwd
student:x:1000:1000:Student User,,,:/home/student:/bin/bash
student@uso:~$ grep student /etc/group
adm:x:4:syslog,student
cdrom:x:24:student
sudo:x:27:student
dip:x:30:student
plugdev:x:46:student
lpadmin:x:116:student
student:x:1000:
sambashare:x:126:student
student@uso:~$ sudo grep student /etc/shadow
[sudo] password for student:
student:$6$VNq0Dxyc$[...].:17749:0:99999:7:::
\end{screen}

Altfel, informații despre utilizatori obținem folosind utilitare precum cele din \labelindexref{Tabelul}{table:user:tools-files}.
Aceste utilitare investighează fișierele de configurare din \labelindexref{Tabelul}{table:user:info-files}.

\begin{table}[!htb]
  \begin{center}
    \begin{tabular}{ p{0.20\textwidth} p{0.35\textwidth} p{0.35\textwidth} }
      \toprule
        \textbf{Utilitar} &
        \textbf{Rol} &
        \textbf{Fișiere investigate} \\
      \midrule
        \cmd{id} &
        informații despre utilizator &
        \file{/etc/passwd}, \file{/etc/group} \\
      \midrule
        \cmd{groups} &
        grupurile utilizatorului curent &
        \file{/etc/group} \\
      \midrule
        \cmd{users}, \cmd{w}, \cmd{who} &
        utilizatorii autentificați în sistem acum &
        \file{/var/run/utmp} \\
      \midrule
        \cmd{whoami} &
        numele utilizatorului curent &
        N/A \\
      \midrule
        \cmd{finger}, \cmd{pinky} &
        informații complete despre un utilizator &
        \file{/etc/passwd}, \file{/etc/group} \\
      \bottomrule
    \end{tabular}
  \end{center}
  \caption{Utilitare de investigare utilizatori}
  \label{table:user:tools-files}
\end{table}

În \labelindexref{Listing}{lst:user:commands} sunt câteva exemple de folosire ale comenzilor de mai sus.

\begin{screen}[caption={Investigarea utilizatorilor prin comenzi},label={lst:user:commands}]
student@uso:~$ id
uid=1000(student) gid=1000(student) groups=1000(student),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)
student@uso:~$ id teacher
uid=1001(teacher) gid=1001(teacher) groups=1001(teacher)
student@uso:~$ groups
student adm cdrom sudo dip plugdev lpadmin sambashare
student@uso:~$ groups teacher
teacher : teacher
student@uso:~$ users
student student
student@uso:~$ whoami
student
student@uso:~$ su - teacher -c whoami
Password:
teacher
student@uso:~$ finger
Login     Name           Tty      Idle  Login Time   Office     Office Phone
student   Student User  *:0             Sep  4 17:42 (:0)
student   Student User   pts/0          Sep 19 20:05 (192.168.56.1)
student@uso:~$ finger teacher
Login: teacher        			Name: Teacher User
Directory: /home/teacher            	Shell: /bin/bash
Never logged in.
No mail.
No Plan.
student@uso:~$ pinky
Login    Name                 TTY      Idle   When             Where
student  Student User        ?:0       ?????  2020-09-04 17:42 :0
student  Student User         pts/0           2020-09-19 20:05 192.168.56.1
\end{screen}

În Linux, anumiți utilizatori au configurat ca shell de login \cmd{/bin/false} sau \cmd{/bin/nologin}.
Aceasta înseamnă că acești utilizatori nu se pot autentifica în sistem și nu pot obține un shell de login.
Acești utilizatori mai sunt numiți și utilizatori de sistem, iar ceilalți sunt numiți utilizatori interactivi.
Utilizatorii de sistem sunt cei care pot avea procese dar nu pot obține shell de login.
Cei interactivi pot obține shell și pot rula apoi comenzi.
La o instalare simplă, o foarte bună parte dintre utilizatorii unui sistem Linux sunt utilizatori de sistem, așa cum se observă în \labelindexref{Listing}{lst:user:system-users}.

\begin{screen}[caption={Afișarea utilizatorilor de sistem},label={lst:user:system-users}]
student@uso:~$ grep /bin/false /etc/passwd
speech-dispatcher:x:111:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/false
whoopsie:x:112:117::/nonexistent:/bin/false
hplip:x:118:7:HPLIP system user,,,:/var/run/hplip:/bin/false
gnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/false
gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false
vboxadd:x:999:1::/var/run/vboxadd:/bin/false

student@uso:~$ grep nologin /etc/passwd
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
[...]
\end{screen}

\subsection{Gestiunea utilizatorilor și grupurilor}
\label{sec:user:groups}

Gestiunea utilizatorilor și grupurilor, însemnând crearea, ștergerea sau modificarea utilizatorilor și grupurilor poate fi făcută, în mod normal, doar de un utilizator privilegiat.
Operațiile de gestiune a utilizatorilor sunt:

\begin{itemize}
  \item crearea unui utilizator: un nou cont de utilizator, identificat de un nume de utilizator (\textit{username}) și un identificator de utilizator (UID) este disponibil în sistem
  \item ștergerea unui utilizator: un cont de utilizator este șters din sistem, nu mai pot fi create procese cu acest utilizator
  \item crearea unui grup: este creat un grup nou în care pot fi adăugați utilizatori
  \item ștergerea unui grup: este șters un grup existent
  \item adăugarea unui utilizator la un grup
  \item ștergerea unui utilizator dintr-un grup
  \item schimbarea parolei unui utilizator
  \item modificarea atributelor unui utilizator: username, login shell, director home
\end{itemize}

Aceste operații de gestiune duc la modificarea fișierelor de configurare sau de tip baze de date din sistem care rețin informațiile despre grupuri și utilizatori.
Operațiile sunt realizate prin utilitare specifice fie din interfața grafică fie din linie de comandă, ca în \labelindexref{Listing}{lst:user:user-group-linux}.

\subsubsection{Gestiunea utilizatorilor și grupurilor în Windows}
\label{sec:user:user-group-windows}

În Windows, gestiunea utilizatorilor și grupurilor o facem din interfața din panoul de control.
Aceasta este uzual accesibilă din \textit{Control Panel $\rightarrow$ User Accounts $\rightarrow$ User Accounts}, ca în \labelindexref{Figura}{fig:user:windows-users}.

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=\textwidth]{chapters/05-user/img/windows-user-accounts.png}
  \caption{Gestiunea utilizatorilor în Windows}
  \label{fig:user:windows-users}
\end{figure}

Pe lângă interfața grafică, uzuală, Windows oferă și utilitare în linia de comandă pentru gestiunea utilizatorilor folosind interfața \cmd{netsh}\footnote{\url{https://docs.microsoft.com/en-us/windows-server/networking/technologies/netsh/netsh-contexts}}.

\subsubsection{Gestiunea utilizatorilor și grupurilor în Linux}
\label{sec:user:user-group-linux}

În Linux există interfețe grafice pentru gestiunea utilizatorilor în funcție de mediul desktop folosit (GNOME, KDE, XFCE etc.) În mod tradițional, gestiunea se face în linia de comandă cu ajutorul utilitarelor specifice, indicate în \labelindexref{Tabelul}{table:user:tools-manage}.

\begin{table}[!htb]
  \begin{center}
    \begin{tabular}{ p{0.30\textwidth} p{0.20\textwidth} p{0.35\textwidth} }
      \toprule
        \textbf{Operație} &
        \textbf{Utilitare} &
        \textbf{Fișiere modificate} \\
      \midrule
        adăugare utilizator &
        \cmd{useradd} &
        \file{/etc/passwd}, \file{/etc/shadow}, \file{/etc/group} \\
      \midrule
        ștergere utilizator &
        \cmd{userdel} &
        \file{/etc/passwd}, \file{/etc/shadow}, \file{/etc/group} \\
      \midrule
        modificare utilizator &
        \cmd{usermod} &
        \file{/etc/passwd}, \file{/etc/shadow}, \file{/etc/group} \\
      \midrule
        adăugare grup &
        \cmd{groupadd} &
        \file{/etc/group} \\
      \midrule
        ștergere grup &
        \cmd{groupdel} &
        \file{/etc/group} \\
      \midrule
        modificare grup &
        \cmd{groupmod} &
        \file{/etc/group} \\
      \midrule
        modificare shell &
        \cmd{chsh} &
        \file{/etc/passwd} \\
      \midrule
        modificare informații utilizator &
        \cmd{chfn} &
        \file{/etc/passwd} \\
      \midrule
        schimbare parolă &
        \cmd{passwd} &
        \file{/etc/shadow} \\
      \bottomrule
    \end{tabular}
  \end{center}
  \caption{Utilitare de gestiune a utilizatorilor}
  \label{table:user:tools-manage}
\end{table}

Pe distribuțiile bazate pe Debian (Debian, Ubuntu, Linux Mint etc.) există un set de utilitare mai ușor de folosit care înglobează comenzile de mai sus, indicate în \labelindexref{Tabelul}{table:user:debian-wrapper}

\begin{table}[!htb]
  \begin{center}
    \begin{tabular}{ p{0.40\textwidth} p{0.40\textwidth} }
      \toprule
        \textbf{Utilitar wrapper} &
        \textbf{Utilitar de bază} \\
      \midrule
        \cmd{adduser} &
        \cmd{useradd} \\
      \midrule
        \cmd{deluser} &
        \cmd{userdel} \\
      \midrule
        \cmd{addgroup} &
        \cmd{groupadd} \\
      \midrule
        \cmd{delgroup} &
        \cmd{groupdel} \\
      \bottomrule
    \end{tabular}
  \end{center}
  \caption{Utilitare wrapper Debian}
  \label{table:user:debian-wrapper}
\end{table}

În Linux/Unix există două tipuri de grupuri: \textbf{grupuri primare} și \textbf{grupuri secundare}.
Un utilizator aparține unui singur grup primar și oricâtor grupuri secundare.
Când un utilizator este creat, i se precizează grupul primar aferent.
Utilitarul usermod poate fi folosit pentru modificarea grupurilor din care face parte un utilizator;
utilitarul are opțiuni distincte pentru modificarea grupului primar și pentru modificarea grupurilor secundare.

Un utilizator neprivilegiat are posibilitatea de a-și modifica anumite informații proprii: shellul de login, numele de utilizator, datele personale, parola.
Pentru aceasta folosește utilitarele din \labelindexref{Tabelul}{table:user:self-manage}.

\begin{table}[!htb]
  \begin{center}
    \begin{tabular}{ p{0.40\textwidth} p{0.40\textwidth} }
      \toprule
        \textbf{Operație} &
        \textbf{Utilitar} \\
      \midrule
        schimbare shell de login &
        \cmd{chsh} \\
      \midrule
        schimbare informații &
        \cmd{chfn} \\
      \midrule
        schimbare parolă &
        \cmd{passwd} \\
      \bottomrule
    \end{tabular}
  \end{center}
  \caption{Utilitare pentru modificare informații proprii}
  \label{table:user:self-manage}
\end{table}

Un grup care este grupul primar al unui utilizator nu poate fi șters.
Întâi trebuie să fie șters utilizatorul, apoi grupul.

În \labelindexref{Listing}{lst:user:user-group-linux} este prezentat un scenariu de lucru cu utilizatori și grupuri în care sunt folosite comenzile specifice din Linux.

\begin{screen}[caption={Gestiunea utilizatorilor și grupurilor în Linux},label={lst:user:user-group-linux}]
student@uso:~$ sudo groupadd courses
student@uso:~$ sudo adduser teacher courses
Adding user `teacher' to group `courses' ...
Adding user teacher to group courses
Done.
student@uso:~$ users teacher
student@uso:~$ id teacher
uid=1001(teacher) gid=1001(teacher) groups=1001(teacher),1002(courses)
student@uso:~$ sudo adduser george
[...]
student@uso:~$ id george
uid=1002(george) gid=1003(george) groups=1003(george)
student@uso:~$ sudo adduser george courses
Adding user `george' to group `courses' ...
Adding user george to group courses
Done.
student@uso:~$ id george
uid=1002(george) gid=1003(george) groups=1003(george),1002(courses)
student@uso:~$ sudo deluser george courses
Removing user `george' from group `courses' ...
Done.
student@uso:~$ id george
uid=1002(george) gid=1003(george) groups=1003(george)
student@uso:~$ sudo delgroup courses
Removing group `courses' ...
Done.
student@uso:~$ id teacher
uid=1001(teacher) gid=1001(teacher) groups=1001(teacher)
student@uso:~$ sudo deluser george
Removing user `george' ...
Warning: group `george' has no more members.
Done.
student@uso:~$ id george
id: 'george': no such user
\end{screen}

Gestiunea parolelor este o componentă critică a sistemului de operare și o vom prezenta în secțiunea de mai jos.

\section{Autentificare. Gestiunea parolelor}
\label{sec:user:auth}

Atunci când un utilizator dorește accesul la sistemul de operare trebuie să se autentifice.
Autentificarea presupune, în mod tipic, furnizarea unui nume de utilizator (\textit{username}) și a unei parole (\textit{password}).
Acest lucru este valabil și pentru aplicații (aplicații web, jocuri, aplicații de baza de date, conturi bancare).
Există și alte moduri de autentificare precum folosirea de informații biometrice (amprentă digitală, retină), dispozitiv de tip token de autentificare, autentificare cu cheie publică.
În această secțiune vom prezenta doar autentificarea pe bază de parole.

\subsection{Baza de date de parole}
\label{sec:user:password-db}

Pentru ca autentificarea să reușească, adică utilizatorului să îi fie permis accesul în sistem, trebuie ca numele de utilizator și parola să fie valide.
Sistemul de operare deține o bază de date cu perechi \textit{(nume de utilizator, parolă)}.
Autentificarea reușește dacă numele de utilizator și parola introduse de utilizator se găsesc în baza de date.

Baza de date de parole este modificată de acțiunile de lucru cu utilizatori.
Adică:

\begin{itemize}
  \item Se adaugă o nouă intrare în baza de date de parole, adică o nouă pereche \textit{(nume de utilizator, parolă)} în momentul adăugării unui utilizator nou în sistem.
  \item Se șterge o intrare existentă în baza de date de parole în momentul ștergerii unui utilizator în sistem.
  \item Se modifică o intrare existentă în baza de date atunci când un utilizator își schimbă parola.
\end{itemize}

Baza de date de parole este o componentă critică a sistemului iar accesul la aceasta trebuie să fie permis numai pentru acțiuni bine definite: autentificare, adăugarea/ștergerea unui utilizator, schimbarea parolei.
Altfel, dacă ar fi permise și alte acțiuni, un utilizator neprivilegiat ar accesa baza de date și ar afla parolele altor utilizatori și ar putea folosi conturile acestora, cel mai periculos fiind folosirea conturilor de utilizatori privilegiați.
De aceea, accesul la baza de date este controlat strict.

Chiar și cu un control strict, se poate întâmpla ca un defect în sistem să permită unui utilizator neprivilegiat accesul la baza de date de parole.
De aceea parolele nu sunt reținute în format citibil (\textit{plain text}), ci sunt criptate.
Dacă un atacator obține în mod nevalid accesul la baza de date de parole, acesta va trebui să decripteze parolele, lucru dificil de realizat.
Atacuri celebre în lume au avut ca rezultat obținerea bazelor de date de parole\footnote{\url{https://en.wikipedia.org/wiki/List\_of\_data\_breaches}}, deci criptarea acestora e foarte importantă.

În Linux, baza de date de utilizatori este reprezentată de fișierul \file{/etc/passwd}.
Întrucât multe comenzi au nevoie de accesul la acest fișier pentru a obține UID-ul când se știe numele de utilizator sau pentru a afla shellul utilizatorului curent, acest fișier nu poate reține parola.
Dacă ar fi așa, orice comenzi uzuale ar putea obține parolele utilizatorilor.
Baza de date de parole este reprezentată în Linux de fișierul \file{/etc/shadow}.
Fișierul \file{/etc/shadow} poate fi accesat doar de utilizatori privilegiați așa cum putem vedea în \labelindexref{Listing}{lst:user:shadow-perm}.

\begin{screen}[caption={Permisiuni de acces pe fișierele de parole},label={lst:user:shadow-perm}]
student@uso:~$ ls -l /etc/passwd
-rw-r--r-- 1 root root 2620 Sep 19 21:08 /etc/passwd
student@uso:~$ ls -l /etc/shadow
-rw-r----- 1 root shadow 1573 Sep 19 21:08 /etc/shadow
\end{screen}

O intrare în fișierul \file{/etc/shadow} conține numele de utilizator, parola criptată și informații legate de gestiunea parolei, așa cum se observă în \labelindexref{Listing}{lst:user:shadow}.

\begin{screen}[caption={Conținutul fișierului /etc/shadow},label={lst:user:shadow}]
student:$6$VNq0Dxyc$[...].:17749:0:99999:7:::
\end{screen}

Pentru informații detaliate despre formatul intrării și al parolei criptate, consultați paginile de manual folosind comenzile \cmd{man shadow} și \cmd{man crypt}.

În Windows, baza de date de parole se numește Security Account Manager (SAM \abbrev{SAM}{Security Account Manager}), și se găsește în \file{\textbackslash{}\%SystemRoot\%\textbackslash{}system32\textbackslash{}config\textbackslash{}SAM}.
Accesul la SAM are loc prin intermediul Windows Registry și este, similar cu \file{/etc/shadow}, permis numai acțiunilor bine definite.
Similar cu \file{/etc/shadow}, parolele sunt reținute criptate.

\subsection{Gestiunea parolelor}
\label{sec:user:manage-passwords}

Un utilizator își poate gestiona parola proprie, iar un utilizator administrativ poate gestiona parola tuturor utilizatorilor.
Gestiunea parolelor înseamnă în mod uzual schimbarea lor dar sunt și alte acțiuni.
O parolă are asociată o durată de viață după care expiră;
odată expirată, o parolă trebuie să fie schimbată.
Altă acțiune legată de parole este blocarea parolei, astfel încât autentificarea cu parolă devine inaccesibilă.
Sumarizând, există următoarele acțiuni de gestiune a parolelor:

\begin{itemize}
  \item schimbarea parolei
  \item stabilirea duratei de viață a unei parole
  \item blocarea parolei
\end{itemize}

În Windows se folosește interfața grafică pentru gestiunea parolelor.
Se accesează \textit{Control Panel $\rightarrow$ User Accounts $\rightarrow$ User Accounts $\rightarrow$ Manage Accounts $\rightarrow$ Change an Account $\rightarrow$ Channge password} ca în \labelindexref{Figura}{fig:user:windows-password}.

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=\textwidth]{chapters/05-user/img/windows-password.png}
  \caption{Gestiunea parolelor în Windows}
  \label{fig:user:windows-password}
\end{figure}

În Linux, modul uzual de gestiune a parolei este prin linia de comandă folosind utilitarul \cmd{passwd}.
Cu ajutorul utilitarului \cmd{passwd}, un utilizator neprivilegiat își poate gestiona parola proprie, iar unul privilegiat parola tuturor utilizatorilor.
Atunci când un utilizator neprivilegiat își gestionează parola folosind utilitarul \cmd{passwd} trebuie să introducă parola la promptul afișat.
În \labelindexref{Listing}{lst:user:passwd} avem exemple de folosire a comenzii \cmd{passwd} pentru gestiunea conturilor.

\begin{screen}[caption={Gestiunea conturilor în Linux folosind passwd},label={lst:user:passwd}]
student@uso:~$ passwd
Changing password for student.
(current) UNIX password:
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully

root@uso:~# passwd teacher
Enter new UNIX password:
Retype new UNIX password:
passwd: password updated successfully
root@uso:~#
\end{screen}

Expirarea parolelor și blocarea parolelor poate fi utilă pentru crearea de conturi temporare.
Cineva primește un cont și apoi nu mai poate să acceseze prin parolă acel cont pentru că nu mai este parte a unei organizații, are de plătit o sumă de bani sau altă situație.

De avut în vedere că o parolă blocată nu înseamnă că acel cont nu poate fi folosit.
Un utilizator se poate autentifica la acel cont folosind alte forme de autentificare, precum autentificare cu chei publice SSH.
Dacă dorim să dezactivăm acel cont și să nu mai poată fi folosit cu nici o formă de autentificare, putem folosi comanda \cmd{usermod} ca în \labelindexref{Listing}{lst:user:disable}.

\begin{screen}[caption={Dezactivarea unui cont},label={lst:user:disable}]
student@uso:~$ sudo usermod --expiredate 1 teacher
student@uso:~$ su - teacher
Password:
Your account has expired;
please contact your system administrator
su: Authentication failure
student@uso:~$
\end{screen}

Comanda configurează contul să expire la \textit{1 ianuarie 1970} făcându-l, astfel, inutilizabil.

Utilitarul \cmd{passwd} este utilitar interactiv, necesită intrarea de la utilizator.
Ceea ce îl face dificil de folosit pentru automatizare;
de exemplu, dacă dorim să creăm \texttt{100} de conturi pe un sistem cu anumite parole.
Pentru aceasta putem folosi utilitarul \cmd{chpasswd}, ca în \labelindexref{Listing}{lst:user:chpasswd}.

\begin{screen}[caption={Schimbarea neinteractivă a parolei folosind chpasswd},label={lst:user:chpasswd}]
student@uso:~$ echo "teacher:woof2PhaiNiphooS" | sudo chpasswd
\end{screen}

Utilitarul \cmd{chpasswd} primește la intrarea standard linii de forma \texttt{username:password} și le schimbă în mod neinteractiv, folosibil în scripturi.
Mai sus am schimbat parola utilizatorului \texttt{teacher} la valoarea \texttt{woof2PhaiNiphooS}.

Dincolo de folosirea lor într-un sistem de operare, pentru o persoană, parolele sunt importante și trebuie avut grijă cum se folosesc.
Așa cum vom discuta detaliat în \labelindexref{Secțiunea}{sec:sec:auth:password}, folosirea parolelor poate fi problematică pentru că:

\begin{itemize}
  \item folosim foarte multe parole și, în mod ideal, trebuie să fie diferite între ele
  \item parolele pot fi slabe și ușor de ghicit
  \item parolele trebuie să fie schimbate periodic, altfel șansele de fi ghicite/decriptate cresc
  \item folosim parolele de pe dispozitive multiple: desktop, laptop, dispozitiv mobil
\end{itemize}

Pentru o gestiune corespunzătoare a parolelor există următoarele recomandări:

\begin{itemize}
  \item Parolele să fie lungi (cel puțin 10 caractere) și să conțină caractere diferite.
    Puteți apela la un generator de parole precum utilitarul \cmd{pwgen}.
  \item Nu notați parolele în clar pe hârtii sau în fișiere de unde pot fi ușor citite.
  \item Folosiți un utilitar de tipul \textit{password manager} care să rețină parolele și să minimizeze riscul expunerii lor la un atacator.
    În același timp, să ajute să fie accesibile de pe dispozitive multiple.
\end{itemize}

\subsection{Autentificare centralizată}
\label{sec:user:centralized-auth}

De multe ori în cadrul unei organizații există mai multe tipuri de aplicații și interfețe pe care le folosim: un site web, un wiki, un cont Linux, un site pentru cursuri, un sistem de gestiune a codului sursă.
Este problematic pentru un utilizator să aibă un cont și o parolă diferită pentru fiecare acest tip de aplicație;
utilizatorul poate uita din parole, poate le va nota undeva, sau le va face simple ca să le țină minte.

Soluția la această situație este autentificarea centralizată.
Autentificarea centralizată presupune existența unui serviciu de autentificare care gestionează baza de date de parole, serviciu accesat de diferitele aplicații, ca în \labelindexref{Figura}{fig:user:centralized-auth}.

\begin{figure}[htbp]
  \centering
  \def\svgwidth{0.7\columnwidth}
  \includesvg{chapters/05-user/img/auth-central.svg}
  \caption{Autentificare centralizată}
  \label{fig:user:centralized-auth}
\end{figure}

În situația autentificării centralizate, un utilizator folosește același nume de utilizator și aceeași parolă pentru toate aplicațiile.
Aplicațiile trimit mai departe numele de utilizator și parola către serviciul de autentificare și, dacă intrările respective sunt valide în baza de date, oferă accesul utilizatorului la aplicație.

În lumea Windows autentificarea centralizată se bazează pe serviciul AD \abbrev{AD}{Active Directory} (\textit{Active Directory}), iar în lumea Linux se bazează pe serviciul LDAP \abbrev{LDAP}{Lightweight Directory Access Protocol} (\textit{Lightweight Directory Access Protocol}).
Aceste subiecte sunt avansate și nu fac subiectul acestei cărți.
Important este înțelegerea nevoii de autentificare centralizată și principalele soluții pentru asigurarea acesteia.

\section{Accesul la sistemul de fișiere}
\label{sec:user:fs-access}

Conturile de utilizator sunt folosite în sistemul de operare pentru a separa resursele la care are acces fiecare utilizator.
Una dintre cele mai folosite resurse este sistemul de fișiere;
fiecare utilizator dispune de un director home la care are permisiuni complete.

În general, unui utilizator i se asociază permisiuni pentru o anumită resursă.
De exemplu, utilizatorul \texttt{ana} poate modifica fișierul \file{note.xls} dacă îi sunt asociate permisiuni de modificare ale acelui fișier.
La nivel conceptual, un agent sau un subiect are anumite permisiuni de acces al unei resurse sau unui obiect, așa cum este descris în \labelindexref{Figura}{fig:user:user-file-perm}.

Schema de mai jos este o schemă generală.
În cazul particular al secțiunii curente, agentul este utilizatorul, iar resursa este fișierul.
Mai precis, agentul este un proces aparținând unui utilizator.
Spunem că un proces poate accesa un anumit fișier dacă utilizatorul căruia aparține procesul are permisiunile aferente la acel fișier.

\begin{figure}[htbp]
  \centering
  \def\svgwidth{0.7\columnwidth}
  \includesvg{chapters/05-user/img/agent-perm.svg}
  \caption{Utilizatori, fișiere, permisiuni}
  \label{fig:user:user-file-perm}
\end{figure}

În multe dintre sistemele de operare moderne, informațiile despre permisiuni sunt reținute în fiecare fișier.
În cadrul fișierului se rețin metadate, printre care și permisiunile de acces pentru utilizatori.
Modul în care sunt structurate aceste metadate ține de sistemul de operare.

\subsection{Gestiunea permisiunilor în Windows}
\label{sec:user:windows-perm}

În Windows permisiunile sunt reținute în forma unor liste de access (\textit{access control lists}, ACL\abbrev{ACL}{Access Control List}).
Adică se creează o listă de utilizatori sau grupuri de utilizatori și permisiuni aferente, ca în \labelindexref{Figura}{fig:user:acl}.

\begin{figure}[htbp]
  \centering
  \def\svgwidth{0.7\columnwidth}
  \includesvg{chapters/05-user/img/acl.svg}
  \caption{Liste de acces (Windows)}
  \label{fig:user:acl}
\end{figure}

În momentul accesului unui fișier de către un proces, se obține utilizatorul căruia aparține procesul.
Apoi, se caută utilizatorul în lista de acces a fișierului.
Dacă există și are asociate permisiuni adecvate, atunci se permite accesul procesului la fișier.
Dacă nu există sau dacă nu are permisiuni, accesul nu este permis.
De obicei în Windows, există o intrare în lista de acces numită \texttt{Everyone} care precizează permisiunile pentru toți utilizatorii.
Dacă, în urma căutării, un utilizator nu este găsit în listă, atunci se folosesc permisiunile pentru intrarea \texttt{Everyone}.
\labelindexref{Figura}{fig:user:windows-check-perm} verifică modul în care sunt analizate permisiunile în Windows.

\begin{figure}[htbp]
  \centering
  \def\svgwidth{0.9\columnwidth}
  \includesvg{chapters/05-user/img/check-perm.svg}
  \caption{Verificarea permisiunilor în Windows}
  \label{fig:user:windows-check-perm}
\end{figure}

În Windows permisiunile sunt prezente doar pe sistemul de fișiere NTFS\abbrev{NTFS}{New Technology File System}, nu și pe FAT32\abbrev{FAT32}{File Allocation Table 32}.
Permisiunile sunt în mod tipic configurate folosind interfața grafică: \textit{click dreapta pe fișier $\rightarrow$ Properties $\rightarrow$ Security}, obținând o fereastră precum cea din \labelindexref{Figura}{fig:user:windows-permissions}.

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=0.5\textwidth]{chapters/05-user/img/windows-permissions.png}
  \caption{Permisiuni în Windows}
  \label{fig:user:windows-permissions}
\end{figure}

Pentru un utilizator dat pot fi precizate mai multe tipuri de permisiuni, dintre care amintim:

\begin{itemize}
  \item \texttt{List Folder}/\texttt{Read Data}: utilizatorul poate lista conținutul unui director și datele unui fișier
  \item \texttt{Create Files}/\texttt{Write Data}: utilizatorul poate crea fișiere într-un director și poate scrie date într-un fișier
  \item \texttt{Traverse Folder}/\texttt{Execute File}: utilizatorul poate traversa un director și poate executa un fișier
\end{itemize}

Aceste permisiuni sunt similare permisiunilor \texttt{read}, \texttt{write} și \texttt{execute} pe care le vom prezenta în continuare pentru Linux.
O listă completă a permisiunilor în Windows, pentru NTFS, găsiți pe site-ul care prezintă sistemul de fișiere NTFS\footnote{\url{http://www.ntfs.com/ntfs-permissions-file-folder.htm}}.

\subsection{Gestiunea permisiunilor în Linux}
\label{sec:user:linux-perm}

În Linux fiecare fișiere are metadate.
Metadatele relevante pentru permisiuni sunt:

\begin{itemize}
  \item \texttt{user} (utilizator): utilizatorul fișierului
  \item \texttt{group} (grup): grupul fișierului
  \item permisiuni: informații despre ce tipuri accese sunt permise și cui
\end{itemize}

În Linux permisiunile sunt reținute într-un mod simplificat.
Există 3 entități pentru care se pot configura permisiuni și 3 tipuri de permisiuni, ținând cont de metadatele fișierului.
Entitățile sunt:

\begin{itemize}
  \item \texttt{user} (utilizator): utilizatorul fișierului
  \item \texttt{group} (grup): grupul fișierului
  \item \texttt{others} (ceilalți): ceilalți utilizatori, diferiți de utilizatorul fișierului și care nu fac parte din grupul fișierului
\end{itemize}

Permisiunile în Linux sunt, de asemenea, simplificate la 3 tipuri:

\begin{itemize}
  \item \texttt{read} (citire): fișierul poate fi citit, directorul poate fi listat
  \item \texttt{write} (scriere): fișierul poate fi modificat, pot fi adăugate / șterse intrări în director
  \item \texttt{execute} (execuție): fișierul poate fi executat, directorul poate fi parcurs
\end{itemize}

Permisiunile în Linux sunt verificate în cazul în care un proces accesează un fișier, urmând pașii:

\begin{enumerate}
  \item Se obține utilizatorul procesului care accesează fișierul.
  \item Se compară utilizatorul procesului cu utilizatorul fișierului.
    Dacă sunt aceiași atunci se obțin permisiunile pentru \texttt{user} (utilizator) și se verifică dacă acțiunea procesului este acceptată de permisiuni.
    Dacă da, accesul este permis;
    dacă nu, se trece la pasul următor.
  \item Se obțin toate grupurile din care face parte utilizatorul procesului.
    Se compară, pe rând, fiecare dintre aceste grupuri cu grupul fișierului.
    Dacă există un grup care să corespundă grupului fișierului, atunci se obțin permisiunile pentru \texttt{group} (grup) și se verifică dacă acțiunea procesului este acceptată de permisiuni.
    Dacă da, accesul este permis;
    dacă nu, se trece la pasul următor.
  \item Se obțin permisiunile pentru \texttt{others} (ceilalți) și se verifică dacă acțiunea procesului este acceptată de permisiuni.
    Dacă da, accesul este permis;
    dacă nu, accesul nu este permis.
\end{enumerate}

Fie următoarea situație de metadate pentru un fișier \file{curs.txt}:

\begin{itemize}
  \item utilizator: \texttt{ana}
  \item grup: \texttt{students}
  \item permisiuni: citire, scriere pentru utilizator, citire pentru grup, nici o permisiune pentru ceilalți
\end{itemize}

Utilizatorul \texttt{corina} încearcă accesarea pentru citire a fișierului folosind comanda \cmd{cat curs.txt}.
Presupunem că utilizatorul \texttt{corina} aparține mai multor grupuri între care și \texttt{students}, grupul fișierului \file{curs.txt}.
Se urmează pașii:

\begin{enumerate}
  \item Se obține utilizatorul procesului care accesează procesul: \texttt{corina}.
  \item Se compară utilizatorul procesului (\texttt{corina}) cu utilizatorul fișierului (\texttt{ana}).
    Nu corespund.
    Se trece la pasul următor.
  \item Se obțin toate grupurile din care face parte utilizatorul procesului (\texttt{corina}).
    Grupul fișirului \file{curs.txt} este \texttt{students}, grup din care face și utilizatorul \texttt{corina}.
    În această situație verificăm dacă acțiunea este permisă.
    Acțiunea este de citire, se găsește în permisiunile pentru grup (citire), și atunci comanda \cmd{cat curs.txt} reușește.
\end{enumerate}

În situația de mai sus, dacă am fi rulat o comandă care modifica fișierul \file{curs.txt}, nu am fi reușit, pentru că permisiunile pentru grup nu includeau \textit{scriere}.

Mai jos prezentăm ce permisiuni sunt necesare pentru a putea rula comenzi de lucru cu sistemul de fișiere:

\begin{itemize}
  \item Pentru a putea traversa un director, pentru ca acesta să fie parte a unei căi este suficient ca acesta să aibă permisiuni de execuție.
    Adică dacă dorim să funcționeze comanda \cmd{cd /a/b/c/d/}, trebuie ca directoarele \file{a}, \file{b}, \file{c} și \file{d} să aibă permisiuni de execuție.
  \item Pentru a putea lista conținutul unui director, adică folosirea comenzii \cmd{ls}, trebuie ca acel director să aibă permisiuni de citire și de execuție.
    Pe un director care are doar permisiuni de citire nu se poate folosi comanda \cmd{ls}.
  \item Pentru a putea afișa conținutul unui fișier, trebuie ca acel fișier să aibă permisiuni de citire iar directorul care-l conține să aibă permisiuni de execuție.
  \item Pentru a putea edita un fișier, trebuie ca acel fișier să aibă permisiuni de scriere (nu neapărat și de citire) iar directorul care-l conține să aibă permisiuni de execuție.
  \item Pentru a putea șterge un fișier sau un director, trebuie ca acel fișier sau director să se găsească într-un director care să aibă permisiuni de scriere și execuție.
  \item Pentru a putea crea un fișier sau un director, trebuie ca acel fișier sau director să fie create într-un director care să aibă permisiuni de scriere și execuție.
  \item Pentru a putea rula un fișier executabil, trebuie ca acel fișier să aibă permisiuni de citire și execuție iar directorul care-l conține să aibă permisiuni de execuție.
\end{itemize}

\subsubsection{Formatul permisiunilor}
\label{sec:user:perm-format}

În mod uzual, permisiunile sunt listate pentru un fișier dat în forma din \labelindexref{Figura}{fig:user:octal-perm}.

\begin{figure}[htbp]
  \centering
  \def\svgwidth{0.7\columnwidth}
  \includesvg{chapters/05-user/img/octal-perm.svg}
  \caption{Permisiuni în Linux}
  \label{fig:user:octal-perm}
\end{figure}

Adică permisiunile sunt listate ca un șir de nouă caractere:

\begin{itemize}
  \item primele trei caractere sunt permisiunile pentru \texttt{user} (utilizator)
  \item următoarele trei caractere sunt permisiunile pentru \texttt{group} (grup)
  \item ultimele trei caractere sunt permisiunile pentru \texttt{others} (ceilalți)
\end{itemize}

\begin{screen}[caption={Listare permisiuni pe fișiere},label={lst:user:list-perm}]
student@uso:~$ ls -l invoice.pdf
-rw-rw-r-- 1 dan staff 0 Sep 19 21:40 invoice.pdf
student@uso:~$ ls -l export_grades
-rwxr-x--- 1 dan adm 0 Sep 19 21:41 export_grades
student@uso:~$ stat invoice.pdf
  File: invoice.pdf
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 801h/2049d	Inode: 658479      Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1002/     dan)   Gid: (   50/   staff)
Access: 2020-09-19 21:40:40.242001000 +0300
Modify: 2020-09-19 21:40:40.242001000 +0300
Change: 2020-09-19 21:41:55.110001000 +0300
 Birth: -
student@uso:~$ stat export_grades
  File: export_grades
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 801h/2049d	Inode: 683312      Links: 1
Access: (0750/-rwxr-x---)  Uid: ( 1002/     dan)   Gid: (    4/     adm)
Access: 2020-09-19 21:41:26.414001000 +0300
Modify: 2020-09-19 21:41:26.414001000 +0300
Change: 2020-09-19 21:42:00.170001000 +0300
 Birth: -
\end{screen}

Astfel, în \labelindexref{Listing}{lst:user:list-perm} avem următoarele:

\begin{itemize}
  \item fișierul \file{invoice.pdf} are:
    \begin{itemize}
      \item permisiuni de citire și scriere pentru \texttt{user}, adică pentru utilizatorul \texttt{dan}
      \item permisiuni de citire și scriere pentru \texttt{group}, adică pentru grupul \texttt{staff}
      \item permisiuni de citire pentru ceilalți
    \end{itemize}
  \item fișierul \file{export_grades} are:
    \begin{itemize}
      \item permisiuni de citire, scriere și execuție pentru \texttt{user}, adică pentru utilizatorul \texttt{dan}
      \item permisiuni de citire și execuție pentru \texttt{group}, adică pentru grupul \texttt{adm}
    \end{itemize}
  \item nici o permisiune pentru ceilalți
\end{itemize}

Pentru gestiunea mai rapidă a permisiunilor, acestea sunt gestionate în format pe biți.
Adică fiecare dintre cele nouă caractere de permisiuni ocupă un bit;
bitul este 1 dacă permisiunea este activă și pe 0 dacă este inactivă.
Adică avem corespondențe de forma:

\begin{itemize}
  \item \texttt{rw-r-{}-r-{}-} corespunde \texttt{110100100}
  \item \texttt{rwxr-x-{}-{}-} corespunde \texttt{111101000}
  \item \texttt{rw-rw-{}-{}-{}-} corespunde \texttt{110110000}
\end{itemize}

Pentru a fi mai rapid, grupurile de biți se grupează câte trei (trei biți pentru \texttt{user}, trei biți pentru \texttt{group}, trei biți pentru \texttt{others}) și cei trei biți se transformă într-o cifră în octal (baza 8);
de aceea mai numim reprezentarea octală.
Avem, așadar, corespondența:

\begin{itemize}
  \item \texttt{rw-r-{}-r-{}-} corespunde \texttt{110100100}, adică \texttt{644} în octal
  \item \texttt{rwxr-x-{}-{}-} corespunde \texttt{111101000}, adică \texttt{750} în octal
  \item \texttt{rw-rw-{}-{}-{}-} corespunde \texttt{110110000}, adică \texttt{660} în octal
\end{itemize}

Pentru că este ușor de modificat și rapid de folosit, gestiunea permisiunilor se face, adesea, în format octal.

\subsection{Comenzi pentru gestiunea permisiunilor}
\label{sec:user:perm-cmd}

Pentru gestiunea permisiunilor avem comenzi de afișare a metadatelor de fișierului (utilizator, grup și permisiuni) și comenzi de modificare a metadatelor.

Pentru afișarea metadatelor, cele două comenzi folosite sunt \cmd{ls -l} și \cmd{stat} ca în \labelindexref{Listing}{lst:user:list-perm}.
În rezultatul rulării comenzilor avem utilizatorul, grupul și permisiunile.

Comenzile de modificare sunt \cmd{chown}, \cmd{chgrp} și \cmd{chmod}.
Primele două comenzi (\cmd{chown} și \cmd{chgrp}) modifică utilizatorul și grupul, iar \cmd{chmod} modifică permisiunile.
Comanda \cmd{chown} poate modifica și utilizatorul și grupul unui fișier, comanda \cmd{chgrp} doar grupul.
Cele două comenzi pot fi rulate doar de utilizatorul privilegiat;
doar acesta poate modifica utilizatorul și grupul unui fișier.
\labelindexref{Listing}{lst:user:chown} conține exemple de folosire a comenzilor \cmd{chown} și \cmd{chgrp}.

\begin{screen}[caption={Modificarea utilizatorului și grupului unui fișier},label={lst:user:chown}]
student@uso:~$ ls -l  invoice.pdf
-rw-rw-r-- 1 dan staff 0 Sep 19 21:40 invoice.pdf
student@uso:~$ sudo chown student invoice.pdf
student@uso:~$ ls -l  invoice.pdf
-rw-rw-r-- 1 student staff 0 Sep 19 21:40 invoice.pdf
student@uso:~$ sudo chown teacher:gdm invoice.pdf
student@uso:~$ ls -l invoice.pdf
-rw-rw-r-- 1 teacher gdm 0 Sep 19 21:40 invoice.pdf
student@uso:~$ sudo chgrp avahi invoice.pdf
student@uso:~$ ls -l invoice.pdf
-rw-rw-r-- 1 teacher avahi 0 Sep 19 21:40 invoice.pdf
\end{screen}

Comanda \cmd{chmod} modifică permisiunile fișierelor.
Comanda poate fi rulată de utilizatorul privilegiat sau de cel ce deține fișierul (\textit{owner}), adică utilizatorul fișierului;
altfel spus, un utilizator își poate modifica permisiunile fișierelor proprii.
Comanda de modificare primește o construcție de modificare a permisiunilor și numele fișierului/fișierelor pentru care dorim schimbarea permisiunilor.
\labelindexref{Listing}{lst:user:chmod} conține exemple de folosire a comenzii \cmd{chmod}:

\begin{screen}[caption={Modificarea permisiunilor unui fișîer},label={lst:user:chmod}]
student@uso:~$ ls -l road-trip.png
-rw-rw-r-- 1 student student 0 Sep 19 21:47 road-trip.png
student@uso:~$ chmod g-w,o+w road-trip.png
student@uso:~$ ls -l road-trip.png
-rw-r--rw- 1 student student 0 Sep 19 21:47 road-trip.png
student@uso:~$ chmod a-r road-trip.png
student@uso:~$ ls -l road-trip.png
--w-----w- 1 student student 0 Sep 19 21:47 road-trip.png
student@uso:~$ chmod u=rw,g=r,o= road-trip.png
student@uso:~$ ls -l road-trip.png
-rw-r----- 1 student student 0 Sep 19 21:47 road-trip.png
student@uso:~$ chmod 644 road-trip.png
student@uso:~$ ls -l road-trip.png
-rw-r--r-- 1 student student 0 Sep 19 21:47 road-trip.png
\end{screen}

Forma în octal a permisiunilor la \cmd{chmod} este preferată atunci când vrem să configurăm un nou set de permisiuni unui fișier.
Când vrem să actualizăm permisiunile și modificările sunt mici, este de preferat să folosim forma în octal a permisiunilor.

\subsubsection{Permisiuni de creare pentru fișiere}
\label{sec:user:umask}

Atunci când creăm un fișier sau director, folosind, de exemplu, comenzile \cmd{touch} și \cmd{mkdir}, le sunt asociate metadate implicite la creare.
Utilizatorul și grupul fișierului vor fi utilizatorul și grupul procesului, care sunt, de obicei, utilizatorul și grupul primar al utilizatorului care a lansat comanda.
Stabilirea permisiunilor la creare ține de \textbf{masca de creare a shellului} (numită și \texttt{umask}).

Masca de creare a shellului este o valoare pe biți care este folosită astfel:

\begin{itemize}
  \item Pentru fișiere se face un \textbf{ȘI logic} între valoarea \texttt{666} (octal) și masca inversată.
  \item Pentru directoare se face un \textbf{ȘI logic} între valoarea \texttt{777} (octal) și masca inversată.
\end{itemize}

Deosebirea între fișiere și directoare apare pentru că directoarele au nevoie de permisiuni de execuție pentru toate operațiile.
Iar fișierele nu au nevoie de permisiuni de execuție;
dacă este cazul acestea trebuie acordate explicit.

Exemple sunt prezente în \labelindexref{Tabelul}{table:user:umask}.

\begin{table}[!htb]
  \begin{center}
    \begin{tabular}{ p{0.20\textwidth} p{0.20\textwidth} p{0.20\textwidth} p{0.20\textwidth} }
      \toprule
        \textbf{Mască de creare} &
        \textbf{Mască inversată} &
        \textbf{Permisiuni de creare fișier} &
        \textbf{Permisiuni de creare director} \\
      \midrule
        \texttt{022} &
        \texttt{755} &
        \texttt{644} &
        \texttt{755} \\
      \midrule
        \texttt{002} &
        \texttt{775} &
        \texttt{664} &
        \texttt{775} \\
      \midrule
        \texttt{077} &
        \texttt{700} &
        \texttt{600} &
        \texttt{700} \\
      \bottomrule
    \end{tabular}
  \end{center}
  \caption{Permisiuni de creare fișier în funcție de mască}
  \label{table:user:umask}
\end{table}

Afișarea și modificarea măștii shellului se face folosind comanda \cmd{umask}.
Fără parametru această comandă afișează masca de creare, iar cu parametru modifică masca de creare, ca în \labelindexref{Listing}{lst:user:umask}.

\begin{screen}[caption={Masca de creare a fișirelor (umask)},label={lst:user:umask}]
student@uso:~$ umask
0002
student@uso:~$ touch ana.txt
student@uso:~$ ls -l ana.txt
-rw-rw-r-- 1 student student 0 Sep 19 21:50 ana.txt
student@uso:~$ mkdir bogdan.dir
student@uso:~$ ls -ld bogdan.dir
drwxrwxr-x 2 student student 4096 Sep 19 21:50 bogdan.dir
student@uso:~$ umask 0022
student@uso:~$ umask
0022
student@uso:~$ touch corina.txt
student@uso:~$ ls -l corina.txt
-rw-r--r-- 1 student student 0 Sep 19 21:51 corina.txt
student@uso:~$ mkdir dan.dir
student@uso:~$ ls -ld dan.dir
drwxr-xr-x 2 student student 4096 Sep 19 21:51 dan.dir
\end{screen}

Tot în \labelindexref{Listing}{lst:user:umask} (liniile \texttt{9--17}) sunt exemple de modificare a umask-ului și crearea de fișiere și directoare pentru a vedea cum modificarea valorii umask duce la modificarea măștii de creare a shellului și, astfel, a permisiunilor de creare pentru fișiere și directoare.

\subsection{Biți speciali de acces: setuid, setgid, sticky}
\label{sec:user:special-bits}

Atunci când afișăm masca de creare a shellului, observăm că sunt patru cifre octale afișate.
În mod normal ar trebui să fie trei cifre afișate, cu permisiuni pentru \texttt{user}, \texttt{group} și \texttt{others}.
Prima cifră afișată reprezintă un set special de trei de biți numiți \texttt{setuid}, \texttt{setgid} și \texttt{sticky}, și sunt activați în această ordine.
 Astfel, pentru permisiunile de mai jos avem explicațiile:

\begin{itemize}
  \item \texttt{4755}: este activat bitul \texttt{setuid}, utilizatorul are permisiuni complete, grupul are permisiuni de citire și execuție, ceilalți au permisiuni de citire și execuție
  \item \texttt{2755}: este activat bitut \texttt{setgid}, celelalte permisiuni sunt ca mai sus
  \item \texttt{1755}: este activat bitul \texttt{sticky}, celelalte permisiuni rămân la fel
\end{itemize}

Bitul \texttt{setuid} are sens când este folosit pe fișiere executabile.
Adaugă funcționalitatea de set user ID on execution.
Când un fișier executabil are activat bitul \texttt{setuid}, procesul creat din acest fișier executabil va avea utilizatorul ale acestui fișier (de obicei \texttt{root}) nu al utilizatorului care a rulat comanda.
Mai concret, dacă rulăm ca utilizator \texttt{student} executabilul \cmd{myexec} care are activat bitul \texttt{setuid} și are ca utilizator \texttt{root}, atunci procesul creat din executabilul \cmd{myexec} va rula ca utilizatorul \texttt{root}.

Bitul \texttt{setuid}, prezentat și în \labelindexref{Secțiunea}{sec:user:altroot} este folosit atunci când anumite utilitare necesită privilegii pentru accesarea unor fișiere speciale atunci când rulează.
În \labelindexref{Listing}{lst:user:use-setuid}, executabilul \file{/usr/bin/passwd} are activat bitul setuid pentru că procesul creat va trebui să acceseze fișierul \file{/etc/shadow}, fișier accesibil doar utilizatorilor privilegiați.

\begin{screen}[caption={Folosirea bitului setuid},label={lst:user:use-setuid}]
student@uso:~$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 59640 Jan 25  2018 /usr/bin/passwd
student@uso:~$ stat /usr/bin/passwd
  File: /usr/bin/passwd
  Size: 59640             Blocks: 120        IO Block: 4096   regular file
Device: 801h/2049d        Inode: 656195      Links: 1
Access: (4755/-rwsr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2018-08-21 11:41:23.741306286 +0300
Modify: 2018-01-25 17:09:22.000000000 +0200
Change: 2018-08-06 17:34:29.848000000 +0300
 Birth: -
\end{screen}

Vedem în rezultatul rulării comenzilor prezența cifrei \texttt{4} pe prima poziție în forma octală a permisiunilor și a caracterului \texttt{s} în forma literală a permisiunilor în locul caracterului de execuție pentru utilizator.
Aceasta înseamnă prezența bitului \texttt{setuid} în permisiunile fișierului.

Bitul \texttt{setgid} are sens când este folosit pe executabile și pe directoare.
Adaugă funcționalitatea de \textit{set group ID on execution}.
Pe executabile are același efect ca bitul \texttt{setuid} doar că pentru grup.

Când un director are activat bitul \texttt{setgid}, viitoarele subdirectoare și fișiere ale acestuia vor avea ca grup în metadate grupul directorului, nu grupul utilizatorului care a rulat comanda.
Viitoarele subdirectoare vor moșteni bitul \texttt{setgid} astfel că ce se creează nou în ierarhie va avea mereu același grup.
Este util pentru a crea un spațiu partajat în care diferiți utilizatori să creeze fișiere dar să rămână accesibile între ei câtă vreme fac parte din același grup.
Mai concret, dacă directorul \file{top/} are grupul \texttt{heroes} și are activat bitul \texttt{setgid}, viitoarele fișiere și subdirectoare vor avea tot grupul \texttt{heroes}, indiferent ce utilizatori au creat intrările.

\labelindexref{Listing}{lst:user:setgid} prezintă cum activarea bitului \texttt{setgid} pe un director duce la crearea de intrări care moștenesc grupul directorului.

\begin{screen}[caption={Folosirea bitului setgid},label={lst:user:setgid}]
student@uso:~$ ls -ld top/
drwxr-xr-x 2 student heroes 4096 Sep 19 21:54 top/
student@uso:~$ sudo chmod g+s top/
student@uso:~$ ls -ld top/
drwxr-sr-x 2 student heroes 4096 Sep 19 21:54 top/
student@uso:~$ mkdir top/alamar
student@uso:~$ ls -ld top/alamar
drwxr-sr-x 2 student heroes 4096 Sep 19 21:55 top/alamar
\end{screen}

Bitul \texttt{sticky} are sens când este folosit pe directoare la care au acces de scriere mai mulți utilizatori, de exemplu directorul \file{/tmp}.
Adaugă funcționalitatea de \textit{restricted deletion flag}.
Acest lucru înseamnă că un utilizator nu poate șterge fișierele altui utilizator, deși are permisiuni de scriere pe directorul care conține acele fișiere.

Directorul \file{/tmp} este cel care are activat bitul \texttt{sticky} pentru că oferă permisiuni complete tuturor utilizatorilor.
Deși un utilizator are permisiuni complete pe acel director, nu poate șterge fișiere care nu-i aparțin, așa cum avem prezentat în \labelindexref{Listing}{lst:user:sticky}.

\begin{screen}[caption={Folosirea bitului sticky},label={lst:user:sticky}]
student@uso:~$ ls -ld /tmp/
drwxrwxrwt 13 root root 4096 Sep 19 21:54 /tmp/
\end{screen}

\section{Anexă: Resetarea parolei în Linux}
\label{sec:user:linux-password-recovery}

Se poate întâmpla să fie uitată parola administrativă pe un sistem care rulează Linux.
În această situație este nevoie de resetarea parolei contului \texttt{root}.
Pentru aceasta avem două opțiuni:

\begin{itemize}
  \item modificarea procesului de boot și înlocuirea procesului init
  \item folosirea unui stick USB \abbrev{USB}{Universal Serial Bus} sau CD bootabil
\end{itemize}

Procesul de boot va fi prezentat detaliat în \labelindexref{Capitolul}{ch:boot}.

În prima variantă, în ecranul bootloader-ului GRUB \abbrev{GRUB}{GRand Unified Bootloader} edităm linia de boot și adăugăm șirul \texttt{init=/bin/bash}, ca în \labelindexref{Figura}{fig:user:grub-init-bash}.

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=0.8\textwidth]{chapters/05-user/img/grub-init-bash.png}
  \caption{Pornirea în shell privilegiat din GRUB}
  \label{fig:user:grub-init-bash}
\end{figure}

Apoi folosim combinația de taste \texttt{Ctrl+x} pentru a boota sistemul de operare.
În această situație primul proces pornit de sistem nu va fi init ci va fi un shell cu permisiuni de \texttt{root}.
În acest shell vom rula comenzile din \labelindexref{Listing}{lst:user:change-root-pw} pentru schimbarea parolei utilizatorului \texttt{root}.

\begin{screen}[caption={Schimbarea parolei contului root în shellul privilegiat},label={lst:user:change-root-pw}]
root@none:~# mount -o remount /
root@none:~# passwd
[...]
\end{screen}

Mai sus am folosit comanda mount pentru a remonta sistemul de fișiere rădăcină în modul \textit{read-write} și a putea astfel modifica fișierul \file{/etc/shadow} cu ajutorul comenzii \cmd{passwd}.

Apoi repornim sistemul fie din buton, fie folosind combinația de taste \texttt{Ctrl+Alt+Del}.
Nu vom putea folosi comenzi precum \cmd{reboot} sau \cmd{poweroff}.

În a doua variantă, folosim un CD/stick USB bootabil cu o distribuție Linux live (precum Ubuntu).
După ce sistemul va porni distribuția live, vom realiza următorii pași:

\begin{enumerate}
  \item Montăm sistemul de fișiere rădăcină al sistemului Linux instalat (pentru care vrem să resetăm parola contului \texttt{root}).
  \item Folosim comanda \cmd{chroot} pentru a modifica sistemul de fișiere rădăcină în care rulăm în sistemul de fișiere al sistemului Linux instalat
  \item Folosim comanda \cmd{passwd} pentru a schimba parola contului \texttt{root} în sistemul de fișiere rădăcină al sistemului Linux instalat.
  \item Revenim la sistemul de fișiere al sistemului live, părăsind shellul obținut prin \cmd{chroot}.
  \item Demontăm sistemul de fișiere rădăcină al sistemului Linux instalat.
  \item Repornim sistemul.
\end{enumerate}

Pașii de mai sus sunt reproduși în comenzile din \labelindexref{Listing}{lst:user:pw-reset-live-cd}.

\begin{screen}[caption={Resetarea parolei contului root cu live CD},label={lst:user:pw-reset-live-cd}]
root@ubuntu:~# mkdir /mnt/rootfs
root@ubuntu:~# mount /dev/sda1 /mnt/rootfs
root@ubuntu:~# chroot /mnt/rootfs
root@ubuntu:~# passwd
[...]
\end{screen}

\section{Use case: Resetarea parolei în Windows}
\label{sec:user:windows-password-recovery}

Pentru resetarea parolei unui utilizator în Windows, cel mai important fiind utilizatorul \texttt{Administrator}, se poate folosi utilitarul \cmd{chntpw} (de la change NT password).
Acesta este inclus în mai multe CD-uri de recuperare (rescue CDs).

O opțiune este folosirea Ultimate Boot CD\footnote{\url{http://www.ultimatebootcd.com}}, un CD bootabil cu utilitare diverse de diagnostic și reparație la nivelul sistemului de operare.
Ultimate Boot CD conține PartedMagic\footnote{\url{https://partedmagic.com}} care, la rândul său, conține utilitarul \cmd{chntpw}.
Utilitarul \cmd{chntpw} oferă interfață în linia de comandă pentru modificarea parolelor utilizatorilor în Windows.

Pentru a nu ocupa spațiu din această carte cu detalii, recomandăm să parcurgeți tutorialul cu screenshot-uri despre folosirea Ultimate Boot CD pentru resetarea parole în Windows\footnote{\url{https://www.top-password.com/blog/reset-forgotten-windows-password-with-ultimate-boot-cd/}}.

\section{Sumar}
\label{sec:user:summary}

Sistemele de operare moderne sunt sisteme multi-utilizator (\textit{multi-user}).
Un sistem dispune de mai mulți utilizatori care coexistă simultan.
Procesele care rulează în sistemul de operare rulează cu permisiunilor acelor utilizatori.

Utilizatorii de sistem sunt acei utilizatori care au acces la resursele unui sistem de operare: sistem de fișiere, rețea, pot rula procese.
Sistemul oferă o bază de date folosită pentru autentificarea utilizatorilor în sistem.

Există un utilizator privilegiat (numit generic \textit{superuser}) care are acces complet la sistem.
Există mecanisme alternative de a oferi privilegii utilizatorilor obișnuiți (neprilegiați).
Gestiunea utilizatorilor, gestiunea rețelei, gestiunea pachetelor sunt acțiuni privilegiate.

Sistemul de operare oferă permisiuni de acces la sistemul de fișiere, componenta cea mai vizibilă.
Permisiunile permit accesul unor utilizator la un fișier dar nu a altor utilizatori.

Modul uzual de accesare a sistemelor de operare moderne este prin intermediul unei parole.
Majoritatea sistemelor oferă opțiuni de resetare a parolei în cazul în care aceasta este pierdută.
