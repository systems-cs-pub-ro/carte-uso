\chapter{Utilizarea sistemului de fișiere}
\label{chapter:fs}

În fiecare zi lucrăm cu diverse fișiere, precum poze, texte sau melodii. De exemplu, le
căutăm prin directoare, le deschidem, le modificăm, le închidem, le ștergem, le
scoatem apoi din Recycle Bin deoarece le șterseserăm din greșeală, și așa mai
departe.

Fișierele sunt, astfel, partea a mai vizibilă și utilizată a sistemului de operare. Ne dorim să avem acces rapid și ușor la fișiere, să le putem localiza rapid și să stocăm cât mai multe date. Aceste nevoi duc la nevoia organizării fișierelor. Pentru a permite căutare rapidă și operații ușor de realizat cu fișierele, acestea sunt organizate într-o structură ierarhică, numită \textbf{sistem de fișiere}.

\section{Noțiuni de bază}
\label{sec:fs:concepts}

Sistemul de fișiere este una dintre componentele centrale ale sistemului de operare, care ne ajută să organizăm cantități impresionante de informații, procese și colaboratori. Sistemul de fișiere are două roluri importante în sistemul de operare:

\begin{itemize}
  \item În primul rând, oferă posibilitatea \textbf{controlului unei cantități tot mai mari de documente}, permițându-ne să găsim un anumit fișier printre mii, milioane sau chiar miliarde de alte fișiere, în sistemele distribuite. Această contribuție este detaliată în \labelindexref{Secțiunea}{sec:fs:filesystem} privind structura ierarhică.
  \item În al doilea rând, sistemele de fișiere \textbf{asigură separarea resurselor între utilizatorii multipli ai unui sistem de calcul}, fie cei umani sau non-umani. Vom discuta importanța acestei trăsături în \labelindexref{Secțiunea}{sec:user:fs-access} dedicată permisiunilor.
\end{itemize}

Sistemele de fișiere sunt diverse, \textbf{construite și optimizate pentru diferite contexte de utilizare}. Nu există un sistem de fișiere optim pentru toată lumea. Pentru a alege un sistem de fișiere trebuie să știm care sunt prioritățile în funcționarea sistemului. De exemplu, creșterea resurselor de stocare a dus la dispariția crizelor de spațiu și a problematicii comprimării în sistemele personale; aceasta este însă tot mai relevantă în arhitecturile \textit{cloud}. În zilele noastre, un utilizator stochează și folosește filme, poze, jocuri pe calculator, documente, mașini virtuale, arhive de informații; acestea ocupă spațiu considerabil pe un sistem laptop sau pe un dispozitiv mobil inteligent sau în Dropbox; acest spațiu ocupat nu mai este însă considerat o problemă dat fiind starea tehnologiilor și serviciilor de stocare.

De asemenea, cerințele ca datele să fie integre și valide (să nu fie corupte) este foarte importantă în sistemele ce lucrează cu date critice, dar mai puțin importantă în sistemele personale, care au mai multă nevoie de simplitate și flexibilitate. Printre criteriile după care putem compara și alege sistemele de fișiere se numără:

\begin{itemize}
  \item asigurarea integrității datelor;
  \item separarea eficientă a resurselor între diferiți utilizatori;
  \item securizarea datelor prin setarea permisiunilor diferențiate de acces;
  \item volumul gestionat: facilitatea în lucrul cu fișiere foarte mari sau cu un număr foarte mare de fișiere;
  \item comprimarea fișierelor (\textit{file compression}) pentru a maximiza spațiul de stocare pe disc (comprimarea înseamnă că aceleași date vor ocupa mai puțin spațiu, dar vor necesita efortul procesorului pentru a le decomprima la fiecare utilizare);
  \item optimizarea spațiului de stocare prin gestiunea fișierelor duplicate și a zonelor ineficient scrise pe disc;
  \item gestiunea posibilelor erori prin jurnalizare și reversibilitate, adică menținerea unei liste a modificărilor ce permite revenirea la o stare anterioară în cazul apariției unei erori.
\end{itemize}

\subsection{Definiții}
\label{sec:fs:defs}

Știm, intuitiv, ce sunt fișierele: sunt documentele noastre electronice, precum pozele, melodiile, proiectele pentru facultate sau programele executabile.

\begin{definition}{fișier}
Fișierul (\textit{file}) reprezintă o formă de organizare digitală a informațiilor, având forma unei înșiruiri de octeți.
\end{definition}

Informațiile sunt organizate în \textbf{fișiere} în vederea utilizării lor printr-o aplicație și a stocării lor de durată. În afara fișierelor create de utilizatorii umani, există și fișiere create de utilizatori automați. Unele dintre acestea sunt esențiale pentru funcționarea sistemului de calcul și sunt ascunse de utilizatorii obișnuiți.

Fișierele sunt organizate la rândul lor în \textbf{directoare}.

\begin{definition}{director}
Un director (\textit{folder} sau \textit{directory}) reprezintă o colecție de fișiere și subdirectoare, identificată printr-un nume.
\end{definition}

Dacă putem înțelege un fișier prin analogie cu o \textbf{foaie} pe care sunt scrise informații, putem înțelege un director prin analogie cu un \textbf{dosar} care conține file de hârtie dar și alte dosare. Un director, ca și un dosar, poate fi și gol.

Această analogie este utilă dar poate fi și înșelătoare. Dintr-o perspectivă tehnică, directoarele sunt tot fișiere. Ele nu ,,conțin'' efectiv fișierele pe care le organizează, așa cum un dosar conține foi, ci doar numele lor - fiind similare cu o foaie pe care am scris o listă de documente. Prin urmare, directoarele în Linux sunt niște fișiere speciale care servesc
organizării altor fișiere și directoare.

\begin{note}[Înțeles pentru \textit{folder} (director)]
Conceptul mai general de director (\textit{folder}), preluat din engleză și în limbajul nostru, se poate referi la forme de organizare a informațiilor care nu au corespondent în sistemul de fișiere. De exemplu, interfețele de email pot permite organizarea mesajelor pe \textit{foldere}. Acestea nu vor fi regăsite în structura ierarhică a sistemului de fișiere, rămânând accesibile doar prin intermediul interfeței în care au fost create.
\end{note}

Fișierele reprezintă informații digitale inscripționate pe mediile fizice de stocare (hard disk, USB stick, DVD etc). Mediile de stocare pot fi considerate spații continue de octeți, pe care putem înscrie multe fișiere, de dimensiuni variabile. Pentru a putea citi sau scrie fișiere pe un mediu de stocare este necesar să cunoaștem sistemul de fișiere utilizat pentru organizarea acestuia.

\begin{definition}{sistem de fișiere}
\textbf{Sistemul de fișiere} este o parte a sistemului de operare ce se ocupă cu numele și atributele fișierelor, pe care le stochează într-o structură ierarhică. Sistemul de fișiere oferă o metodă de organizare fizică și logică a fișierelor într-un mediu de stocare:

\begin{itemize}
  \item stocarea fișierelor ca o înșiruire de octeți reprezintă organizarea fizică;
  \item modul în care sunt adresate fișierele reprezintă organizarea logică.
\end{itemize}
\end{definition}

Sistemul de fișiere ajută astfel utilizatorul să stocheze și să organizeze datele digitale pentru acces facil. \labelindexref{Figura}{fig:fs:def-fs} prezintă rolul sistemului de fișiere în organizarea datelor; orgnizarea este de obicei ierarhică așa cum este prezentat în \labelindexref{Secțiunea}{sec:fs:filesystem}.

\begin{figure}[htbp]
  \centering
  \def\svgwidth{0.5\columnwidth}
  \includesvg{chapters/02-fs/img/def-fs.svg}
  \caption{Sistemul de fișiere ca organizator de date digitale}
  \label{fig:fs:def-fs}
\end{figure}

Fișierele sunt folosite de sistemul de operare pentru a organiza atât datele provenite de la utilizator, cât și cele generate de sistem. În sistemul de fișiere sunt stocate și organizate poze, documente, notițe ale utilizatorului, dar și fișiere de configurare, fișiere de tip jurnal (\textit{log files}), baze de date necesare funcționării sistemului.

Deoarece este important ca utilizatorii să poată accesa fișierele stocate, sistemul de operare pune la dispoziție o interfață pentru a putea lucra cu sistemul de fișiere. În funcție de preferințe, există două tipuri de interfețe, așa cum descris în \labelindexref{Capitolul}{chapter:ui}: interfața în linia de comandă (CLI) expusă de interpretorul de comenzi (shellul CLI) și interfața grafică (GUI) prezentată de exemplu de un browser de sistem de fișiere.

\subsection{Structura ierarhică a sistemului de fișiere}
\label{sec:fs:filesystem}

De la an la an avem tot mai multe fișiere pe calculatoare și telefoane. Acumulăm poze, video-uri, melodii, precum și documente de la școală sau de la birou. Ce-ar însemna să găsim o poză într-o colecție de un milion de poze? Sistemul de fișiere oferă o interfața ierarhică care permite organizarea și căutarea informației.

O structură \textbf{ierarhică}, sau arborescentă, apare atunci când fișierele sunt organizate în directoare (\textit{folders}). Un director poate conține mai multe fișiere dar și alte directoare, fiecare dintre care poate conține mai multe fișiere dar și alte directoare și tot așa, până când ultimul director va conține doar fișiere sau va fi gol. Un director este analog unei crengi dintr-un arbore, pe care pot crește alte crengi dar și frunze (fișierele). Pe frunze nu crește nimic.

Să examinăm următorul exemplu. Pentru a găsi o poză anume (de exemplu, \file{selfiecumotanul-mai2018.jpg}) într-o colecție de 1.000.000 de poze, utilizatorul ar trebui să ceară sistemului de fișiere să parcurgă toate pozele până când găsește numele fișierului căutat. În cel mai rău caz, va trebui să parcurgă toate cele 1.000.000 de nume.

Ce se întâmplă însă dacă apelăm la o organizare pe trei niveluri, grupând pozele câte 100, la fel ca în \labelindexref{Figura}{fig:fs:ex-3-lvl}? Pe primul nivel, vom avea 100 de directoare. În fiecare dintre ele, includem 100 de subdirectoare. Apoi, în fiecare subdirector includem 100 de poze. Astfel, am stocat într-o ierarhie cu trei niveluri \texttt{100 directoare * 100 subdirectoare * 100 poze = 1.000.000 poze}.

\begin{figure}[htbp]
  \centering
  \def\svgwidth{\columnwidth}
  \includesvg{chapters/02-fs/img/3-lvl-fs.svg}
  \caption{Exemplu de organizare ierarhică pe 3 niveluri a unui set de 1.000.000 poze}
  \label{fig:fs:ex-3-lvl}
\end{figure}

Cum putem găsi acum poza? Adresa ei ne va indica unde anume se află, în arborele de fișiere. De exemplu, dacă adresa sa completă este: Directorul \file{99/cat-pics/selfiecumotanul-mai2018.jpg}, sistemul de fișiere va căuta întâi directorul \file{99} printre cele 100 de directoare de pe primul nivel. Apoi, va căuta \file{cat-pics} printre cele 100 de subdirectoare din directorul 99.  Apoi, în cele din urmă, va căuta poza dorită. În cel mai rău caz, sistemul de fișiere va realiza, de trei ori la rând, o căutare între 100 de elemente.

Prin structura arborescentă cu 3 niveluri am înlocuit deci o căutare într-un sac cu 1.000.000 elemente, pe care o singură persoană o realizează în ore dacă nu zile, cu o căutare în trei punguțe cu 100 de elemente fiecare, care este ușor de realizat chiar și manual, de o singură persoană.

Prin organizarea arborescentă pe directoare, un număr mare de fișiere pot fi gestionate la nivelul unei singure persoane. Sistemul de fișiere transformă astfel complexitatea volumului imens de informații și o face accesibilă pentru utilizatorul uman. Mai mult despre găsirea fișierelor se află în \labelindexref{Secțiunea}{sec:fs:search} privind comenzile de căutare (\cmd{find}, \cmd{locate}, \cmd{whereis}, \cmd{which} și \cmd{type}).

Există însă un cost pentru acest control sporit al complexității. Fiecare director este un element suplimentar, creat de sistemul de fișiere, care trebuie să fie și el stocat undeva și ocupă astfel resurse. Aceste directoare nu există în structura plată, în care economisim astfel spațiu. În exemplul de mai sus, în structura ierarhică avem în total 100*100=10.000 directoare, create special pentru a organiza cele 1.000.000 de poze. Prin urmare, raportându-ne la numărul inițial de fișiere, pentru a controla mai bine informațiile plătim un cost de 10.000 / 1.000.000 = 1\%.

Prezentăm în continuare exemple concrete de organizare a fișierelor în sistemele de operare moderne.

În \labelindexref{Tabelul}{table:fs:linux-fs} este prezentată structura ierarhică în Linux.

\begin{table}[!htb]
\begin{center}
  \begin{tabular}{ p{0.2\textwidth} p{0.7\textwidth} }
  \toprule
    \textbf{Director} & \textbf{Conținut} \\
  \midrule
    \file{/} & directorul rădăcină (\textit{root directory}) -- directorul cel mai cuprinzător, care conține celelalte directoare, considerate analoage trunchiului și ramurilor. \\
  \midrule
    \file{/bin} & comenzi esențiale necesare bootării, întreținerii și depanării sistemului\\
  \midrule
    \file{/boot} & fișiere necesare bootării, precum imaginea kernel-ului\\
  \midrule
    \file{/dev} & fișiere speciale utilizate pentru accesul direct la dispozitivele hardware sau logice ale sistemului\\
  \midrule
    \file{/etc} & fișiere pentru configurarea sistemului, precum \file{inittab}, \file{fstab} și \file{hosts}\\
  \midrule
    \file{/home} & fișierele fiecărui utilizator din sistem - datele unui utilizator se găsesc în \file{/home/username}\\
  \midrule
    \file{/media} & subdirectoare în care se montează unitățile optice, floppy etc.\\
  \midrule
    \file{/mnt} & subdirectoare în care se montează alte sisteme de fișiere\\
  \midrule
    \file{/opt} & pachete de aplicații de dimensiuni mari, accesibile tuturor utilizatorilor\\
  \midrule
    \file{/proc} & sistem virtual de fișiere din care se obțin informații despre sistem și aplicațiile care rulează la un moment dat\\
  \midrule
    \file{/root} & directorul home al utilizatorului root\\
  \midrule
    \file{/sbin} & comenzi de bază accesibile numai utilizatorului
    root\\
  \midrule
    \file{/tmp} & fișiere temporare\\
  \midrule
    \file{/usr} & aplicații pentru uzul normal al sistemului de operare - \file{/usr/local} conține aplicațiile instalate/compilate de utilizator\\
  \midrule
    \file{/var} & fișiere al căror conținut se schimbă foarte des, precum log-uri, fișiere temporare, cache (date reutilizabile), spool (date neprocesate)\\
  \bottomrule
  \end{tabular}
\end{center}
\caption{Ierarhia într-un sistem de fișiere din mediul Linux}
\label{table:fs:linux-fs}
\end{table}

În \labelindexref{Figura}{fig:fs:linux-fs} prezentăm cum arată grafic o ierarhie a sistemului de fișiere. Observăm că în rădăcină se află directoarele \file{home/}, \file{bin/}, \file{usr/} etc. În directorul \file{home/} se află subdirectoarele \file{ubuntu/} și \file{myuser/} ș.a.m.d.

\begin{note}[Folosire caracter \texttt{/} (\textit{slash})]
Atunci când folosim nume de directoare în Linux vom prefera să folosim sufixul \texttt{/} (\textit{slash}) pentru a indica faptul că sunt directoare.
\end{note}

\begin{figure}[htbp]
  \centering
  \def\svgwidth{0.7\columnwidth}
  \includesvg{chapters/02-fs/img/linux-fs.svg}
  \caption{Ierarhia într-un sistem de fișiere din mediul Linux}
  \label{fig:fs:linux-fs}
\end{figure}

Ierarhia sistemului de fișiere în macOS este apropiată celei din Linux.

Structura fișierelor în Windows diferă față de cea din Linux. Aceasta este mai simplă și majoritatea directoarelor importante se află în \file{C:\textbackslash{}Windows}, așa cum se observă în \labelindexref{Tabelul}{table:fs:windows-fs}.

\begin{table}[htb]
\begin{center}
  \begin{tabular}{ p{0.32\textwidth} p{0.62\textwidth} }
  \toprule
    \textbf{Director} & \textbf{Conținut} \\
  \midrule
    \file{C:\textbackslash{}} & directorul rădăcină \\
  \midrule
    \file{C:\textbackslash{}Windows} & Windows-ul și fișierele aferente \\
  \midrule
    \file{C:\textbackslash{}Documents and Settings} & configurările utilizatorilor și date specifice acestora \\
  \midrule
    \file{C:\textbackslash{}Program Files} & aplicații \\
  \midrule
    \file{C:\textbackslash{}Windows\textbackslash{}System32} & drivere și fișiere de configurare Windows \\
  \midrule
    \file{C:\textbackslash{}Documents and Settings\textbackslash{}username\textbackslash{}My Documents} & datele unui utilizator (aceasta este calea implicită, ea poate fi modificată) \\
  \bottomrule
  \end{tabular}
\end{center}
\caption{Ierarhia într-un sistem de fișiere din Windows}
\label{table:fs:windows-fs}
\end{table}

Deși în Linux și în macOS avem un singur director rădăcină, Windows are simultan pentru fiecare sistem de fișiere câte un director rădăcină:

\begin{itemize}
  \item \file{A}, \file{B}: de obicei sunt rezervate pentru floppy disk-uri
  \item \file{C}: partiția de pe hard disk; pot exista mai multe, cărora li se asociază litere în ordine
  \item \file{D} (sau următoarea literă disponibilă după partițiile de pe hard disk-uri): se referă la CD-ROM/DVD-Rom
\end{itemize}

Windows alocă literele în funcție de partiții, nu după sistemul de fișiere. Dacă se modifică sistemul de fișiere de pe o partiție, litera asignată partiției va rămâne aceeași. Pe o partiție se poate afla la un moment dat un singur sistem de fișiere.

În \labelindexref{Tabelul}{table:fs:compare-lin-win} de mai jos avem o comparație între căile importante din sistemele de operare cele mai cunoscute.

\begin{table}[htb]
{\scriptsize
\begin{center}
  \begin{tabular}{ p{0.15\textwidth} p{0.25\textwidth} p{0.25\textwidth} p{0.25\textwidth} }
  \toprule
  \textbf{Descriere} & \textbf{Windows} & \textbf{Linux} & \textbf{Mac OS} \\
  \midrule
    rădăcină & \file{C:} & \file{/} & \file{/} \\
  \midrule
    director home & \file{C:\textbackslash{}Documents and Settings\textbackslash{}username} & \file{/home/username} & \file{/Users/username} \\
  \midrule
    aplicații & \file{C:\textbackslash{}Program Files} & \file{/bin}; \file{/sbin}; \file{/usr/bin}; \file{/usr/sbin}; \file{/usr/local/bin}; & \file{/opt/*/bin} \file{/Applications}; \file{/bin}; \file{/sbin} \\
  \midrule
    configurări ale sistemului & Windows Registry & directoare specifice fiecărei \ aplicații, aflate în home-ul utilizatorului; \file{/etc} & \file{/Users/username/ Library}; \file{/etc} \\
  \bottomrule
  \end{tabular}
\end{center}
}
\caption{Comparație între căile sistemelor de operare}
\label{table:fs:compare-lin-win}
\end{table}

Observăm că în Linux înșiruirea de directoare este separată de caracterul \file{/} (\textit{slash}), în timp ce în mediile Windows se folosește \file{\textbackslash{}} (\textit{backslash}).

\subsection{Căi relative și căi absolute}
\label{sec:fs:path}

Revenind la exemplul din \labelindexref{Figura}{fig:fs:linux-fs}, dorim să găsim poza \file{selfiecumotanul-mai2018.jpg}, care se află în subdirectorul \file{cat-pics}, în directorul \file{99}. Pentru a putea accesa poza, avem două posibilități: putem sa folosim o cale relativă sau o cale absolută. Alegerea căii pe care o vom folosi depinde de unde ne aflăm în momentul respectiv în ierarhia de fișiere și unde se află fișierul căutat. O cale este echivalentul unei adrese pentru identificarea fișierului.

\begin{definition}{Cale absolută}
\textbf{Calea absolută} reprezintă adresa completă a fișierului, începând cu directorul rădăcină. Astfel, o cale absolută va începe cu \file{/} (\textit{slash}) sau \file{\textasciitilde{}} (tildă, \textit{tilde}) în cazul Linux/macOS sau cu \file{C:}, \file{D:} etc, în cazul Windows.
\end{definition}

\begin{definition}{Cale relativă}
\textbf{Calea relativă} este o cale ce pornește din directorul curent. Pornind din directorul curent se construiește o cale către fișierul destinație dorit. O cale relativă \textbf{nu} începe cu \file{/} (\textit{slash}) sau \file{\textasciitilde{}} (tildă, \textit{tilde}) în cazul Linux/macOS sau cu \file{C:}, \file{D:} etc, în cazul Windows.
\end{definition}

\begin{note}[Directorul \textit{home}]
Simbolul \file{\textasciitilde{}} este o prescurtare în Linux/macOS pentru directorul \textit{home} al utilizatorului. De obicei acesta este \file{/home/$<$username$>$/} în Linux și în \file{/Users/$<$username$>$/} în macOS.
\end{note}

În fiecare director se găsesc \textbf{două directoare speciale}: \file{.} (punct) și \file{..} (punct punct). Directorul \file{.} (\textit{punct}) indică spre același director, directorul curent. \file{..} (\textit{punct punct}) indică spre directorul părinte în ierarhia de fișiere și directoare.

Pentru a ne întoarce în ierarhia de fișiere pas cu pas, ne folosim de \file{..} pentru a ajunge în directorul părinte. Putem să înlănțuim mai multe grupări \file{..} (de ex. \file{../../..}) pentru a ne întoarce mai sus în ierarhie. Avem un exemplu de comenzi în \labelindexref{Listing}{lst:fs:dot-dot}.

\begin{screen}[caption={Referința .. către directorul părinte},label={lst:fs:dot-dot}]
student@uso:~$ pwd
/home/student
student@uso:~$ cd uso.git/labs/
student@uso:~/uso.git/labs$ pwd
/home/student/uso.git/labs
student@uso:~/uso.git/labs$ cd ..
student@uso:~/uso.git$ pwd
/home/student/uso.git
student@uso:~/uso.git$ cd ../..
student@uso:/home$ pwd
/home
student@uso:/home$ cd
student@uso:~$ pwd
/home/student
student@uso:~$ cd /usr/local
student@uso:/usr/local$ pwd
/usr/local
\end{screen}

În exemplu de mai sus am folosit comanda \cmd{pwd} (\textit{print working directory}) pentru a afișa directorul curent (numit și director de lucru). Directorul este indicat și în promptul comenzii, între caracterul \texttt{:} (două puncte) și caracterul \texttt{\$} (dolar); simbolul \texttt{$\sim$} (tildă) este echivalent pentru directorul home al utilizatorului, în cazul de mai sus \texttt{/home/student/}. Comanda \cmd{cd} (\textit{change directory}) schimbă directorul curent; comanda primește ca argument o cale care poate fi cale relativă sau absolută.

La linia 6 din exemplu de mai sus am schimbat directorul de lucru în directorul părinte folosind comanda \cmd{cd ..} și am urcat un nivel în ierarhia de directoare; observăm că este afișată o cale mai scurtă la linia 8 (\file{/home/student/uso.git}) față de calea anterioară de la linia 5 (\file{/home/student/uso.git/labs}). La linia 9 este o cale relativă (\file{../..}) care urcă două niveluri în ierarhie. La linia 12 avem comanda \cmd{cd} fără argumente; această folosire a comenzii schimbă directorul de lucru în directorul home al utilizatorului, în cazul nostru \file{/home/student/}. La linia 15 avem o cale absolută (care începe cu \texttt{/} (\textit{slash})): \file{/usr/local}; comanda \cmd{cd} primește ca argument această cale și schimbă directorul curent în \file{/usr/local}.

Până acum am prezentat doar când folosim directorul special \file{..} (punct punct).

De multe ori, folosim construcția \file{.} (punct), care indică directorul curent, pentru comenzi ce execută scripturi/programe din acel director. Dacă în directorul curent avem un executabil numit \texttt{list\_permissions}, atunci îl vom putea rula folosind comanda:

\begin{screen}
student@uso:~$ ./list_permissions
\end{screen}

Aceasta înseamnă să se execute executabilul \file{list\_permissions} din directorul curent.

Construcția \file{.} (punct) poate fi folosită în situații în care dorim să referim directorul curent. De exemplu dacă dorim să copiem un fișier în directorul curent rulăm o comandă similară cu cea de pe linia 5 din \labelindexref{Listing}{lst:fs:dot}.

\begin{screen}[caption={Referința . către directorul curent},label={lst:fs:dot}]
student@uso:~$ pwd
/home/student
student@uso:~$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos  examples.desktop  uso.git  vm-actions-log.txt
student@uso:~$ cp /etc/passwd .
student@uso:~$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos  examples.desktop  passwd  uso.git  vm-actions-log.txt
\end{screen}

În exemplu de mai sus am folosit comanda \cmd{ls} (\textit{list}) pentru a afișa conținutul directorului curent (chiar directorul home \file{/home/student}). Apoi, la linia 5 am folosit comanda \cmd{cp} (\textit{copy}) pentru a copia fișierul \file{/etc/passwd} (cale absolută), dat ca primul argument, în directorul curent, reprezentat de construcția \file{.} (punct), dat ca al doilea argument. Apoi, la afișarea conținutului directorului (folosind comanda \cmd{ls}) vedem prezența fișierului \texttt{passwd}, acum copiat. În exemplu am folosit construcția \file{.} (punct) pentru a referi directorul curent, destinația comenzii de copiere.

\section{Formatul fișierelor}
\label{sec:fs:file-format}

Din perspectiva utilizatorului, fișierele se împart în diverse categorii, precum muzică, poze, jocuri și altele. Toate acestea sunt văzute de calculator ca o colecție de biți ce trebuie prelucrați pentru a putea fi redați. Calculatorul prelucrează fișierele în funcție de \textbf{formatul} acestora, pentru a ști ce programe sunt necesare pentru a le putea deschide și pentru a putea lucra cu ele.

Pentru început, putem clasifica fișierele în două mari categorii: fișiere de tip text (\textit{text file}) și fișiere binare (\textit{binary file}).

\begin{itemize}
  \item \textbf{Fișierele de tip text} conțin linii compuse din caractere citibile (litere, cifre, semne de punctuație) fără să conțină elemente ce trebuie să fie interpretate de un program (precum grafice, cod executabil etc). Fișierele text pot conține text simplu (\textit{plain text}), având extensia \texttt{.txt}, sau care conți cod sursă (de exemplu cu extensia \texttt{.c} sau \texttt{.java}) sau formate de prezentare precum HTML.
  \item \textbf{Fișierele binare} sunt toate fișierele care nu sunt de tip text, putând reprezenta: imagini, programe executabile, melodii, fișiere comprimate etc.
\end{itemize}

Formatul (sau tipul) fișierelor se referă la modul de codificare a informației în fișier, care permite apoi redarea sau utilizarea informației prin intermediul unei interfețe sau a unei aplicații. Formatul fișierului specifică felul în care informația va fi codificată în biți, în mediul digital.

Formatul fișierului este, de regulă, asociat cu \textbf{extensia} acestuia. Extensia reprezintă sufixul de la finalul numelui fișierului, separat de numele fișierului printr-un punct. Exemple de extensii sunt: \texttt{.txt} (fișiere text), \texttt{.tex} (document sursă LaTeX), \texttt{.mp3} (format audio), \texttt{.bmp} (imagine tip \textit{bitmap}), \texttt{.png} (imagine tip \textit{Portable Network Graphic}), etc.

Este important să remarcăm că, \textbf{dacă schimbăm manual extensia unui fișier, nu înseamnă că i-am schimbat tipul}. Formatul fișierului ține de proprietățile conținutului acestuia și nu se schimbă dacă modificăm numele sau extensia. Dacă, de exemplu, avem un fișier text în care am pus versurile cântecului ,,The Kinslayer'' al formației Nightwish, și schimbăm numele fișierului din \file{kinslayer.txt} în \file{kinslayer.mp3}, fișierul text nu devine dintr-o dată cântec și, desigur, nu îl vom putea deschide cu o aplicație de tip MP3 player.

Fișierele pot fi convertite dintr-un format într-altul, de regulă în interiorul categoriilor mari de conținut. De exemplu, putem converti un fișier \texttt{.wav} într-un fișier \texttt {.mp3}, sau un fișier \texttt{.bmp} într-un fișier \texttt{.png}, sau un fișier \texttt{.doc} într-un fișier \texttt{.pdf}. Este posibil să convertim și fișiere în formate ce par foarte diferite, de exemplu un fișier \texttt{.txt} într-un fișier \texttt{.mp3}, apelând la soluții automate text-to-speech. Convertirea se realizează nu prin schimbarea manuală a extensiei, ci prin intermediul unei aplicații cu care deschidem fișierul și îl transformăm în formatul dorit.

Pentru a vedea de ce tip este un fișier în Linux, dincolo de extensie, folosim comanda \cmd{file}. Mai jos avem exemple de folosire a comenzii \cmd{file} pentru determinarea tipului unui fișier. Pentru fiecare fișier primit ca argument de comanda \cmd{file} sunt indicate informații despre tipul fișierului: executabil, imagine de kernel, script shell, fișier comprimat, fișier imagine. \labelindexref{Listing}{lst:fs:file} conține exemple de rulare a comenzii \cmd{file}.

\begin{screen}[caption={Aflarea tipului unui fișier (comanda file)},label={lst:fs:file}]
student@uso:~$ file /bin/ls
/bin/ls: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=9567f9a28e66f4d7ec4baf31cfbf68d0410f0ae6, stripped
student@uso:~$ file /boot/vmlinuz-4.15.0-29-generic
/boot/vmlinuz-4.15.0-29-generic: Linux kernel x86 boot executable bzImage, version 4.15.0-29-generic (buildd@lgw01-amd64-057) #31-Ubuntu SMP Tue Jul 17 15:39:52 UTC 2018, RO-rootFS, swap_dev 0x7, Normal VGA
student@uso:~$ file /etc/init.d/ssh
/etc/init.d/ssh: POSIX shell script, ASCII text executable
student@uso:~$ file /usr/share/man/man1/cp.1.gz
/usr/share/man/man1/cp.1.gz: gzip compressed data, max compression, from Unix
student@uso:~$ file /usr/share/pixmaps/htop.png
/usr/share/pixmaps/htop.png: PNG image data, 128 x 128, 8-bit/color RGBA, non-interlaced
\end{screen}

În \labelindexref{Listing}{lst:fs:file} am analizat cinci fișiere folosind comanda \cmd{file} și au rezultat următoarele tipuri:
\begin{itemize}
  \item fișierul \file{/bin/ls} este un executabil de tip ELF (\textit{Executable and Linking Format})
  \item fișierul \file{/boot/vmlinuz-4.15.0-29-generic} este o imagine de nucleu (\textit{kernel}) de sistem de operare
  \item fișierul \file{/etc/init.ssh} este un script shell
  \item fișierul \file{/usr/share/man/man1/cp.1.gz} este un fișier comprimat de format GZIP
  \item fișierul \file{/usr/share/pixmaps/htop.png} este un fișier imagine PNG
\end{itemize}

Comanda \cmd{file} lucrează independent de extensia fișierului. Acest lucru este avantajos deoarece extensia poate să fie atribuită greșit de către utilizator, precum putem vedea și în \labelindexref{Listing}{lst:fs:file-wrong-extension}. Chiar dacă extensia fișierul a fost schimbată din \texttt{.jpg} în \texttt{.txt}, comanda \cmd{file} detectează în continuare tipul corect al fișierului: fișier de tip imagine JPEG.

\begin{screen}[caption={Detectarea tipului unui fișier cu extensie greșită},label={lst:fs:file-wrong-extension}]
student@uso:~$ file photo.jpg
photo.jpg: JPEG image data, JFIF standard 1.01
student@uso:~$ mv photo.jpg fisier.txt
student@uso:~$ file fisier.txt
fisier.txt: JPEG image data, JFIF standard 1.01
\end{screen}

\subsection{Atributele fișierelor}
\label{sec:fs:file-attr}

Pentru a controla funcționarea sistemelor de fișiere este importantă distincția dintre \textbf{date} și \textbf{metadate}. Un fișier conține efectiv informații sau date, precum muzică, versuri, imagini sau bilete de avion.

\begin{definition}{Metadatele unui fișier}
\textbf{Metadatele} sunt informații despre informații: cantitatea informațiilor, data ultimei accesări, cine le-a creat, cine le-a modificat, unde anume au fost editate ultima dată.
\end{definition}

Sistemele de fișiere se bazează pe crearea și gestionarea metadatelor referitoare la fișiere. Aceste metadate poartă denumirea de \textbf{atribute}. Ele fac posibilă accesarea eficientă și securizată a informațiilor.

În Linux putem afișa atribute ale fișierelor folosind comanda \cmd{ls} cu opțiunea \texttt{-l}; opțiunea înseamnă \textit{long listing} și este folosită pentru afișarea detaliată (cu atribute a fișierelor), ca în \labelindexref{Listing}{lst:fs:long-listing}. În \labelindexref{Listing}{lst:fs:long-listing} vedem pe coloane, atribute ale fișierelor, precum: permisiuni, informații legate de posesie (utilizator), dimensiune, data ultimei modificări, numele fișierului.

\begin{screen}[caption={Afișarea atributelor fișierelor (folosind ls)},label={lst:fs:long-listing}]
student@uso:~$ ls -l
total 60
drwxr-xr-x  2 student student 4096 aug  6 17:41 Desktop
drwxr-xr-x  3 student student 4096 aug 20 21:00 Documents
drwxr-xr-x  2 student student 4096 aug  6 17:41 Downloads
drwxr-xr-x  2 student student 4096 aug  6 17:41 Music
drwxr-xr-x  2 student student 4096 aug  6 17:41 Pictures
drwxr-xr-x  2 student student 4096 aug  6 17:41 Public
drwxr-xr-x  2 student student 4096 aug  6 17:41 Templates
drwxr-xr-x  2 student student 4096 aug  6 17:41 Videos
-rw-r--r--  1 student student 8980 aug  6 17:37 examples.desktop
-rw-r--r--  1 student student 2506 sep 30 11:28 passwd
drwxr-xr-x 15 student student 4096 aug 24 14:52 uso.git
-rw-r--r--  1 student student 4827 aug 21 14:37 vm-actions-log.txt
\end{screen}

Cele mai simple atribute ale unui fișier sunt numele, dimensiunea și tipul. Tipul fișierului este indicat de primul caracter din rezultatul rulării comenzii \cmd{ls -l}, și poate fi:

\begin{itemize}
  \item \texttt{-} = regular file
  \item \texttt{b} = block special file
  \item \texttt{c} = character special file
  \item \texttt{d} = directory
  \item \texttt{l} = symbolic link
  \item \texttt{n} = network file
  \item \texttt{p} = fIFO
  \item \texttt{s} = socket
\end{itemize}

În rularea din \labelindexref{Listing}{lst:fs:long-listing} avem fișiere (primul caracter este \texttt{-}) și directoare (primul caracter este \texttt{d}).

Alte atribute importante descriu permisiunile, adică operațiile pe care diferite tipuri de utilizatori le pot realiza asupra respectivului fișier. Informații detaliate privind \textbf{tipurile de utilizatori} și configurarea permisiunilor acestora se regăsesc în \labelindexref{Capitolul}{chapter:user}.

\begin{itemize}
  \item \texttt{r} = permisiunea de a citi fișierul
  \item \texttt{w} = permisiunea de a scrie în fișier
  \item \texttt{x} = permisiunea de a executa fișierul
  \item \texttt{-} = absența permisiunii
\end{itemize}

\section{Operații uzuale asupra fișierelor și directoarelor}
\label{sec:fs:file-ops}

Sistemul de fișiere ne permite realizarea mai multor tipuri de operațiuni asupra fișierelor. Operațiile uzuale asupra fișierelor includ: afișarea și schimbarea directorului, afișarea conținutului fișierului, listarea fișierelor dintr-un director, crearea fișierelor sau a directoarelor, copierea, mutarea, redenumirea sau ștergerea acestora, precum și arhivarea/dezarhivarea și realizarea unei versiuni de backup.

O problemă poate apărea dacă doi utilizatori doresc să citească sau să modifice același fișier simultan, deoarece nu este clar dacă acțiunile celor doi nu se vor încurca reciproc. De aceea, una dintre responsabilitățile sistemului de fișiere este să mențină separarea resurselor resurselor între utilizatori. Vom prezenta detaliat aceste aspecte în \labelindexref{Capitolul}{chapter:user}.

\subsection{Afișarea și schimbarea directorului curent}
\label{sec:fs:pwd-cd}

Pentru a afișa directorul curent folosim comand \cmd{pwd} (\textit{print working directory}). De asemenea, dacă nu s-au efectuat manual schimbări asupra prompt-ului bash, aceste va afișa implict directorul în care ne aflăm. Dacă dorim să ne mutăm în alt director, vom folosi comanda \cmd{cd $<$cale$>$}. Comanda \cmd{cd} are ca parametru o cale absolută sau relativă către destinația în care vrem să ajungem.

Urmărim cum funcționează cele două comenzi -- \cmd{pwd} și \cmd{cd} -- în \labelindexref{Listing}{lst:fs:pwd-cd}. Vedem cum se modifică prompt-ul shellului atunci când schimbăm directorul curent. Atunci când schimbăm directorul,

\begin{screen}[caption={Schimbarea directorului curent},label={lst:fs:pwd-cd}]
student@uso:~$ pwd
/home/student
student@uso:~$ cd ..
student@uso:/home$ pwd
/home
student@uso:/home$ cd ../usr/bin/
student@uso:/usr/bin$ pwd
/usr/bin
student@uso:/usr/bin$ cd .
student@uso:/usr/bin$ pwd
/usr/bin
student@uso:/usr/bin$ cd /
student@uso:/$ pwd
/
student@uso:/$ cd
student@uso:~$ pwd
/home/student
student@uso:~$ cd /usr/bin
student@uso:/usr/bin$ pwd
/usr/bin
student@uso:/usr/bin$ cd /home
student@uso:/home$ pwd
/home
student@uso:/home$ cd -
/usr/bin
student@uso:/usr/bin$ pwd
/usr/bin
student@uso:/usr/bin$ cd ~
student@uso:~$ pwd
/home/student
student@uso:~$ cd ././././
student@uso:~$ pwd
/home/student
student@uso:~$ cd ../..
student@uso:/$ pwd
/
\end{screen}

În exemplu de mai sus:
\begin{itemize}
  \item \cmd{cd ..} (comanda de la linia 3) ne întoarce în directorul părinte
  \item \cmd{cd ../usr/bin} (comanda de la linia 6) este o cale relativă care pornește din directorul părinte al directorului curent
  \item \cmd{cd .} (comanda de la linia 9) nu modifică directorul, deoarece \file{.} (punct) face referire la directorul curent
  \item \cmd{cd \textasciitilde} (comanda de la linia 28) ne deplasează în directorul home al utilizatorului curent; \file{\textasciitilde} (tildă) este echivalentul directorului home pentru utilizatorul curent
  \item \cmd{cd} (comanda de la linia 15) schimbă directorul tot în directorul home
  \item \cmd{cd -} (comanda de la linia 24) ne întoarce în directorul în care ne aflam anterior
\end{itemize}

\subsection{Listarea fișierelor}
\label{sec:fs:ls}

Acum că știm să navigăm dintr-un director în altul, ne interesează să afișăm conținutul acestora. Comanda pe care o folosim este \cmd{ls [opțiuni] <cale>}. Dacă dorim să listăm conținutul directorului curent, executăm comanda \cmd{ls} fără a mai fi nevoie să specificăm calea.

În continuare găsim opțiunile folosite frecvent pentru această comandă:

\begin{itemize}
  \item \texttt{-l} = afișează detalii despre fiecare director/fișier, precum dimensiunea, utilizator, grup, data modificare, drepturi
    de acces
  \item \texttt{-a} = afișează toate fișierele, inclusiv cele ascunse (cele care încep cu \file{.} (caracterul punct))
  \item \texttt{-h} = afișează dimensiunea fișierelor în format ușor de înțeles, respectiv dimensiunea în octeți este înlocuită cu dimensiunea în Kocteți/Mocteți/Gocteți dacă depășește un anumit ordin de mărime
\end{itemize}

Un exemplu de utilizare a opțiunii \texttt{-l} a comenzi \cmd{ls} se găsește în \labelindexref{Listing}{lst:fs:ls-l}.

\begin{screen}[caption={Opțiunea -l a comenzii ls},label={lst:fs:ls-l}]
student@uso:~$ ls -l uso.git/README.md
-rw-r--r-- 1 student student 146 aug 20 20:57 uso.git/README.md
\end{screen}

În output-ul de pe linia 2 din \labelindexref{Listing}{lst:fs:ls-l}:

\begin{itemize}
  \item primul caracter ne spune tipul fișierului, în cazul de față fișier obișnuit
  \item următoarele 3 grupuri de caractere (\texttt{rwx}) reprezintă permisiunile de acces, pe care le vom detalia în \labelindexref{Capitolul}{chapter:user}
  \item \texttt{student} este utilizatorul fișierului \item \texttt{student} (a doua apariție) este grupul de care aparține fișierul
  \item \texttt{146} este dimensiunea fișierului, în octeți
  \item \texttt{aug 20 20:57} este data ultimei modificări a fișierului
  \item \texttt{20:28} este ora ultimei modificări
  \item \texttt{uso.git/README.md} este numele fișierului
\end{itemize}

\labelindexref{Listing}{lst:fs:ls} conține alte exemple de folosire a comenzii \cmd{ls}, cu următoarele exeplicații:

\begin{itemize}
  \item comanda de la linia 19 (\cmd{ls -l}) afișează toate informațiile (\texttt{-l}) ale tuturor fișierelor, ascunse și neascunse, din directorul curent; dimensiunea fișierelor este afișată în format inteligibil (\textit{human-readable}) (\texttt{-h}); observăm că sunt sunt afișate și directoarele standard \file{.} și \file{..}
  \item comanda de la linia 38 primește o cale relativă pentru a-i afișa conținutul
  \item comanda de la linia 41 afișează toate fișierele, ascunse și neascunse, din rădăcina ierarhiei de fișiere și directoare (\file{/})
\end{itemize}

\begin{screen}[caption={Folosirea comenzii ls},label={lst:fs:ls}]
student@uso:~$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos  examples.desktop  passwd  uso.git  vm-actions-log.txt
student@uso:~$ ls ~
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos  examples.desktop  passwd  uso.git  vm-actions-log.txt
student@uso:~$ ls -l
total 60
drwxr-xr-x  2 student student 4096 aug  6 17:41 Desktop
drwxr-xr-x  3 student student 4096 aug 20 21:00 Documents
drwxr-xr-x  2 student student 4096 aug  6 17:41 Downloads
drwxr-xr-x  2 student student 4096 aug  6 17:41 Music
drwxr-xr-x  2 student student 4096 aug  6 17:41 Pictures
drwxr-xr-x  2 student student 4096 aug  6 17:41 Public
drwxr-xr-x  2 student student 4096 aug  6 17:41 Templates
drwxr-xr-x  2 student student 4096 aug  6 17:41 Videos
-rw-r--r--  1 student student 8980 aug  6 17:37 examples.desktop
-rw-r--r--  1 student student 2506 sep 30 11:28 passwd
drwxr-xr-x 15 student student 4096 aug 24 14:52 uso.git
-rw-r--r--  1 student student 4827 aug 21 14:37 vm-actions-log.txt
student@uso:~$ ls -lh
total 60K
drwxr-xr-x  2 student student 4,0K aug  6 17:41 Desktop
drwxr-xr-x  3 student student 4,0K aug 20 21:00 Documents
drwxr-xr-x  2 student student 4,0K aug  6 17:41 Downloads
drwxr-xr-x  2 student student 4,0K aug  6 17:41 Music
drwxr-xr-x  2 student student 4,0K aug  6 17:41 Pictures
drwxr-xr-x  2 student student 4,0K aug  6 17:41 Public
drwxr-xr-x  2 student student 4,0K aug  6 17:41 Templates
drwxr-xr-x  2 student student 4,0K aug  6 17:41 Videos
-rw-r--r--  1 student student 8,8K aug  6 17:37 examples.desktop
-rw-r--r--  1 student student 2,5K sep 30 11:28 passwd
drwxr-xr-x 15 student student 4,0K aug 24 14:52 uso.git
-rw-r--r--  1 student student 4,8K aug 21 14:37 vm-actions-log.txt
student@uso:~$ ls -a
.              .bash_history  .config   .gconf      .local    .sudo_as_admin_successful  .vboxclient-display.pid      .viminfo   Downloads  Templates         uso.git
..             .bash_logout   .dbus     .gitconfig  .mozilla  .tmux                      .vboxclient-draganddrop.pid  .vimrc     Music      Videos            vm-actions-log.txt
.ICEauthority  .bashrc        .emacs    .gnupg      .profile  .tmux.conf                 .vboxclient-seamless.pid     Desktop    Pictures   examples.desktop
.bash_aliases  .cache         .emacs.d  .lesshst    .ssh      .vboxclient-clipboard.pid  .vim                         Documents  Public     passwd
student@uso:~$ ls ../..
bin   cdrom  etc   initrd.img      lib    lib64   lost+found  mnt  proc  run   snap  swapfile  tmp  var      vmlinuz.old
boot  dev    home  initrd.img.old  lib32  libx32  media       opt  root  sbin  srv   sys       usr  vmlinuz
student@uso:~$ ls -a /
.   bin   cdrom  etc   initrd.img      lib    lib64   lost+found  mnt  proc  run   snap  swapfile  tmp  var      vmlinuz.old
..  boot  dev    home  initrd.img.old  lib32  libx32  media       opt  root  sbin  srv   sys       usr  vmlinuz
\end{screen}

O opțiune folosită a comenzii \cmd{ls} este \texttt{-R}, care afișează recursiv directoarele și fișierele ce au ca rădăcină directorul dat ca argument, exemplificată în \labelindexref{Listing}{lst:fs:ls-R}. Prin recursiv înțelegem că trece prin toate directoarele pornind de la directorul dat ca argument.

\begin{screen}[caption={Listarea recursivă a conținutului unui director},label={lst:fs:ls-R}].
student@uso:~$ ls -R /usr/local/lib/
/usr/local/lib/:
python2.7  python3.6

/usr/local/lib/python2.7:
dist-packages  site-packages

/usr/local/lib/python2.7/dist-packages:

/usr/local/lib/python2.7/site-packages:

/usr/local/lib/python3.6:
dist-packages

/usr/local/lib/python3.6/dist-packages:
\end{screen}

Dacă dorim să folosim alte opțiuni, putem să consultăm \cmd{man ls} sau \cmd{ls -{}-help}.

\subsection{Afișarea conținutului fișierelor}
\label{sec:fs:file-content}

Pentru a putea vedea ce conține un fișier, folosim comanda \cmd{cat $<$nume fișier$>$}, ca în \labelindexref{Listing}{lst:fs:cat}.

\begin{screen}[caption={Afișarea conținutului unui fișier},label={lst:fs:cat}]
student@uso:~$ cat /etc/default/saned
# Defaults for the saned initscript, from sane-utils

# To enable under systemd please read README.Debian
# Set to yes to start saned under SysV
RUN=no

# Set to the user saned should run as
RUN_AS_USER=saned
\end{screen}

Comanda va întoarce conținutul întregului fișier, indiferent de lungime. Pentru ca utilizatorul să poată naviga prin tot output-ul comenzii, putem folosi comanda \cmd{less}, ca mai jos:

\begin{screen}
student@uso:~$ less /etc/X11/Xsession
\end{screen}

Comanda \cmd{less} are o interfață asemănătoare cu cea a editorului \cmd{vim} și permite navigarea în ambele direcții, linie cu linie.

\subsection{Crearea fișierelor/directoarelor}
\label{sec:fs:file-create}

Pentru a crea un fișier gol, avem două metode. Prima metoda este utilizarea comenzii \cmd{touch $<$nume fișier$>$}, iar a doua se bazează pe o funcționalitate a shellului numită redirectare în fișier, ca în \labelindexref{Listing}{lst:fs:create-file}, cu următoarele explicații:
\begin{itemize}
  \item comanda de la linia 1 folosește prima metodă; creează un fișier gol cu numele \file{cats.txt} în directorul curent
  \item comanda de la linia 2 folosește a doua metodă; redirectează (\texttt{>}) ieșirea unei comenzi nule într-un fișier, ducând la trunchierea fișierului, dacă există, sau, în cazul nostru, ducând la crearea fișierului gol \file{dogs.txt}
  \item vedem din rezultatul rulării comenzii \texttt{ls -l} de la linia 5 că ambele fișiere sunt create cu dimensiune 0, sunt goale
\end{itemize}

\begin{screen}[caption={Crearea unui fișier},label={lst:fs:create-file}]
student@uso:~/Downloads$ touch cats.txt
student@uso:~/Downloads$ > dogs.txt
student@uso:~/Downloads$ ls
cats.txt  dogs.txt
student@uso:~/Downloads$ ls -l
total 0
-rw-rw-r-- 1 student student 0 sep 30 12:20 cats.txt
-rw-rw-r-- 1 student student 0 sep 30 12:20 dogs.txt
\end{screen}

Comanda \cmd{touch} are în principal rolul pentru a actualiza data ultimei accesări sau modificări asupra fișierului; dacă un fișier nu există, acesta este creat cu data curentă; crearea fișierului este un rol secundar al comenzii \cmd{touch}. În \labelindexref{Listing}{lst:fs:touch} folosim comanda \cmd{touch} pentru a schimba data ultimei modificări din \texttt{aug 20 20:57} în \texttt{sep 30 12:24}.

\begin{screen}[caption={Schimbarea datei ultimei modificări a unui fișier},label={lst:fs:touch}]
student@uso:~$ ls -l uso.git/README.md
-rw-r--r-- 1 student student 146 aug 20 20:57 uso.git/README.md
student@uso:~$ touch uso.git/README.md
student@uso:~$ ls -l uso.git/README.md
-rw-r--r-- 1 student student 146 sep 30 12:24 uso.git/README.md
\end{screen}

\subsubsection{Crearea legăturilor simbolice}
\label{sec:fs:link}

Exemplu următor prezintă crearea legăturilor simbolice, un mod prin care același fișier poate fi referit din două căi, echivalentul scurtăturilor.

\begin{screen}
student@uso:~$ cat uso.git/README.md
uso
===

   * Directorul ''lab02'' contine toate fisierele si structura de directoare necesare rezolvarii laboratorului 2 de catre studenti
student@uso:~$ ln -s uso.git/README.md readme_link
student@uso:~$ ls -l readme_link
lrwxrwxrwx 1 student student 17 sep 30 12:28 readme_link -> uso.git/README.md
student@uso:~$ cat readme_link
uso
===

   * Directorul ''lab02'' contine toate fisierele si structura de directoare necesare rezolvarii laboratorului 2 de catre studenti
\end{screen}

În exemplul de mai sus am creat intrarea \file{readme\_link} care este o legătură simbolică spre fișierul \cmd{uso.git/README.md}. Dacă afișăm, folosind comanda \cmd{cat}, fișierul sau legătura simbolică, obținem același conținut: legătura simbolică referă același fișier.

Legăturile (\textit{linkurile}) numite și legături simbolice (\textit{symbolic links}) sunt create cu ajutorul comenzii \texttt{ln} căreia îi transmitem ca argument opțiunea \texttt{-s}.

\subsubsection{Crearea directoarelor}
\label{sec:fs:mkdir}

Pentru a crea un director folosim comanda \cmd{mkdir} ca în \labelindexref{Listing}{lst:fs:dir-create}.

\begin{screen}[caption={Crearea directoarelor},label={lst:fs:dir-create}]
student@uso:~$ mkdir games
student@uso:~$ ls -d games/
games/
student@uso:~$ ls -ld games/
drwxrwxr-x 2 student student 4096 sep 30 17:28 games/
student@uso:~$ ls games/
student@uso:~$ mkdir games/warcraft
student@uso:~$ mkdir games/lol
student@uso:~$ ls games/
lol  warcraft
student@uso:~$ mkdir -p games/heroes/3/nighon/mutare
student@uso:~$ ls -ld games/heroes/3/nighon/mutare
drwxrwxr-x 2 student student 4096 sep 30 17:32 games/heroes/3/nighon/mutare
\end{screen}

În \labelindexref{Listing}{lst:fs:dir-create} am creat directorul \file{games/} iar în cadrul său am creat subdirectoarele \file{warcraft/} și \file{lol/}. Comanda \cmd{ls} afișează conținutul unui diretor; dacă dorim să afișăm informații despre director în sine folosim comanda opțiunea \texttt{-d} a comenzii \cmd{mkdir}; o formă frecventă este folosirea opțiunii \texttt{-ld} pentru afișarea informațiilor despre director în format lung, cu atribute ale directorului. În partea finală a exemplului am folosit opțiunea \texttt{-p} a comenzii \cmd{mkdir} pentru a crea un director cu toate directoarele părinte necesare chiar dacă acestea nu există.

În \labelindexref{Tabelul}{table:fs:create} sunt sumarizate comenzile de creare a tipurilor de intrări în sistemul de fișiere.

\begin{table}[htb]
\begin{center}
  \begin{tabular}{ p{0.3\textwidth} p{0.6\textwidth} }
  \toprule
    \textbf{Tip de intrare} & \textbf{Comandă} \\
  \midrule
    fișier obișnuit (regular file) & \cmd{touch \textless{}nume\_fișier>} sau \newline \cmd{> \textless{}nume\_fișier>} \\
  \midrule
    director & \cmd{mkdir \textless{}nume\_director>} \\
  \midrule
    legătură (link) & \cmd{ln -s \textless{}destinatie> [\textless{}nume\_legătură>]} \\
  \bottomrule
  \end{tabular}
\end{center}
\caption{Comenzi pentru crearea intrărilor în sistemul de fișere}
\label{table:fs:create}
\end{table}

\subsection{Copiere / mutare / redenumire / ștergere}
\label{sec:fs:cp-mv-rm}

Operațiile frecvente cu fișiere sunt copierea, mutarea sau redenumirea și ștergerea. Copierea înseamnă că un fișier sau director este duplicat în alt loc, și se găsește acum în două locuri. Mutarea / Redenumirea înseamnă cu un fișier sau director este acum mutat din locul său inițial în alt loc în sistemul de fișiere; spre deosebire de copiere, acum fișierul / directorul se găsește într-un singur loc. Ștergerea înseamnă eliminarea acelui fișier sau director din sistemul de fișiere; nu se va mai găsi în nici un loc.

Comenzile de copiere și mutare primesc doi parametri:

\begin{itemize}
  \item primul parametru reprezintă sursa de unde dorim să copiem/mutăm
  \item al doilea parametru reprezintă destinația unde dorim să copiem/mutăm
\end{itemize}

\begin{note}[Observație]
Primul parametru (sursa) al comenzilor din acest subcapitol poate fi reprezentată și prin globbing în sistemul de fișiere, despre care vom discuta detaliat în \labelindexref{Capitolul}{chapter:cli}.
\end{note}

\subsubsection{Copierea}
\label{sec:fs:cp}

Comanda folosită pentru a copia un fișier este \cmd{cp $[$opțiuni$]$ $<$sursă$>$ $<$destinație$>$}. În \labelindexref{Listing}{lst:fs:cp} este prezentat un exemplu de copiere a unui fișier și unul de copiere a unui director. Pentru copierea unui director folosim opțiunea \texttt{-r} a comenzii \cmd{cp} pentru copiere recursivă (care trece prin toate subdirectoarele).

\begin{screen}[caption={Copierea fișierelor și directoarelor},label={lst:fs:cp}]
student@uso:~$ cp passwd passwd-copy
student@uso:~$ ls -l passwd passwd-copy
-rw-r--r-- 1 student student 2506 sep 30 11:28 passwd
-rw-r--r-- 1 student student 2506 sep 30 16:48 passwd-copy
student@uso:~$ cmp passwd passwd-copy
student@uso:~$ cp uso.git/labs/01-fs/wiki/basics.wiki .
student@uso:~$ cmp basics.wiki uso.git/labs/01-fs/wiki/basics.wiki
student@uso:~$ cp -r uso.git/labs/ .
student@uso:~$ diff -r uso.git/labs/ labs/
student@uso:~$
\end{screen}

În \labelindexref{Listing}{lst:fs:cp}, în primă fază facem o copie, în același director a fișierul \file{passwd} în fișierul \file{passwd-copy}. Apoi folosim comanda \cmd{ls -l} pentru a vedea că cele două fișiere au aceeași dimensiune (\texttt{2506}). Comanda \cmd{cmp} compară două fișiere și, dacă sunt identice, nu afișează nimic. Apoi copiem un fișier dintr-o cale relativă (\file{uso.git/labs/01-fs/wiki/basics.wiki}) în directorul curent, indicat de construcția \file{.} (punct). Folosim comanda \cmd{cmp} pentru a valida că cele două fișiere sunt identice. Apoi copiem un director dintr-o cale relativă (\file{uso.git/labs/}) în directorul curent. Pentru a compara două directoare și pentru a demonstra că sunt identice, folosim comanda \cmd{diff} cu opțiunea \texttt{-r}, pentru parcurgere recursivă a argumentelor de comparat.

\subsubsection{Mutarea / Redenumirea}
\label{sec:fs:mv}

Comanda folosită pentru a muta/redenumi un fișier este \cmd{mv $[$opțiuni$]$ $<$sursă$>$ $<$destinație$>$}. Mutarea se va face implicit recursiv și va păstra toate atributele fișierelor. Când se execută comanda \cmd{mv}, se schimbă doar părintele fișierului (sau directorului) pe care îl mutăm. Spre deosebire de comanda \cmd{cp}, comanda \cmd{mv} nu primește opțiunea \texttt{-r} pentru mutarea unui director; o intrare este mutată indiferent dacă este director sau fișier.

\labelindexref{Listing}{lst:fs:mv} conține exemple de folosire a comenzii \cmd{mv}.

\begin{screen}[caption={Mutarea / Redenumirea fișierelor și directoarelor},label={lst:fs:mv}]
student@uso:~$ mv basics.wiki 01-fs-basics.wiki
student@uso:~$ ls basics.wiki 01-fs-basics.wiki
ls: cannot access 'basics.wiki': No such file or directory
01-fs-basics.wiki
student@uso:~$ mv passwd-copy Downloads/
student@uso:~$ ls passwd-copy
ls: cannot access 'passwd-copy': No such file or directory
student@uso:~$ ls Downloads/passwd-copy
Downloads/passwd-copy
student@uso:~$ mv labs/ labs-old
student@uso:~$ ls labs
ls: cannot access 'labs': No such file or directory
student@uso:~$ ls labs-old/
00-intro  01-fs  02-process  03-user  04-appdev  05-cli  06-hw-boot  07-storage  08-net  09-vm  10-sec  11-ctf
\end{screen}

În \labelindexref{Listing}{lst:fs:mv} am redenumit fișierul \file{basics.wiki} în \file{02-fs-basics.wiki}. Am mutat fișierul \file{passwd-copy} în subdirectorul \file{Downloads/}, dat prin cale relatativă. Și am redenumit directorul \file{labs/} în \file{labs-old/}. La fiecare operație de mutare/redenumire am verificat că vechea intrare nu mai este disponibilă, dar este disponibilă noua intrare.

\subsubsection{Ștergerea fișierelor/directoarelor}
\label{sec:fs:rm}

Ștergerea unei intrări înseamnă eliminarea acelei intrări și a conținutului său din sistemul de fișiere. Comanda cea mai folosită pentru ștergerea fișierelor și directoarelor este
\cmd{rm $[$opțiuni$]$ $<$cale$>$}. Opțiunile cele mai des folosite pentru această comandă sunt:

\begin{itemize}
  \item \texttt{-r/-R}: se utilizează atunci când se dorește ștergerea recursivă a unui director
  \item \texttt{-f}: se utilizează pentru a șterge forțat fișierele
\end{itemize}

Este important să fim atenți când folosim această comandă și opțiunile ei, pentru a nu șterge informații utile din greșeală și apoi să nu le mai putem recupera. Una dintre cele mai întâlnite erori este \cmd{rm -rf /}, care șterge recursiv toate fișierele începând cu rădăcina.

\begin{note}[Observație]
Dacă dorim să ștergem un director gol, putem să folosim comanda
\cmd{rmdir $<$director\_gol$>$}
\end{note}

\labelindexref{Listing}{lst:fs:rm} conține exemple de folosire a comenzilor \cmd{rm} și \cmd{rmdir}.

\begin{screen}[caption={Ștergerea fișierelor și directoarelor},label={lst:fs:rm}]
student@uso:~$ ls
02-fs-basics.wiki  Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos  examples.desktop  labs-old  passwd  readme_link  uso.git  vm-actions-log.txt
student@uso:~$ rm 02-fs-basics.wiki
student@uso:~$ rm passwd
student@uso:~$ rm readme_link
student@uso:~$ rm -fr labs-old
student@uso:~$ rmdir Downloads/
rmdir: failed to remove 'Downloads/': Directory not empty
student@uso:~$ rm Downloads/*
student@uso:~$ rmdir Downloads/
student@uso:~$ ls
Desktop  Documents  Music  Pictures  Public  Templates  Videos  examples.desktop  uso.git  vm-actions-log.txt
\end{screen}

În \labelindexref{Listing}{lst:fs:rm} am șters, folosind comanda \cmd{rm} fișierele \file{basics-wiki} și \file{passwd} și legătura simbolică \file{readme\_link}. Apoi am șters recursiv (folosind opțiunea \texttt{-fr} (de la \textit{force and recursive}) directorul \file{labs-old/}. Comanda \cmd{rmdir} poate șterge un director doar dacă acesta este gol; pentru aceasta am șters toate fișierele din directorul \file{Downloads/} folosind construcția \file{Downloads/*}; apoi am folosit comanda \cmd{rmdir} pentru a șterge directorul. Am folosit comanda \cmd{ls} la început și la sfârșit pentru a demonstra ștergerea fișierelor.

\subsection{Căutarea fișierelor}
\label{sec:fs:search}

Structura ierarhică a sistemului de fișiere permite găsirea rapidă a unui fișier parcurgând pe rând subdirectoarele care-l conțin. Chiar și așa sunt situații în care nu se știe precis unde este localizat un fișier sa un director și este utilă căutarea acestuia. Pentru a căuta un fișier după numele său există două tipuri de căutări:
\begin{itemize}
  \item \textbf{căutare indexată} în care fișierele sunt inspectate și informațiile despre localizarea lor sunt reținute într-o bază de date cu fișierele indexată;
  \item \textbf{căutare exhaustivă} în cadrul unei zone din ierarhia sistemului de fișiere, trecând prin toate fișierele
\end{itemize}

Pentru căutare indexată folosim, în Linux, comanda \cmd{locate} (și comanda \cmd{updatedb}). Pentru căutare exhaustivă folosim, în Linux, comanda \cmd{find}. Le prezentăm în continuare.

\subsubsection{Comanda locate}
\label{sec:fs:locate}

Comanda \cmd{locate} caută în toate fișierele indexate într-o bază de date locală. Avantajul său este căutarea rapidă în sistemul de fișiere. Are două dezavantaje:
\begin{enumerate}
  \item Baza de date trebuie actualizată periodic pentru a indexa modificările din sistemul de fișiere. Actualizarea se face folosind comanda \cmd{updatedb}.
  \item Căutarea se face strict după nume, nu și după alte atribute ale fișierelor.
\end{enumerate}

Rezultatul rulării comenzii este o listă cu toate fișierele al căror nume conține șirul de caractere trimis ca argument.

În \labelindexref{Listing}{lst:fs:locate} se caută toate fișierele al căror nume conține șirul \texttt{pwd}.

\begin{screen}[caption={Căutarea fișierelor folosind locate},label={lst:fs:locate}]
student@uso:~$ locate pwd
/bin/pwd
/etc/.pwd.lock
/lib/modules/4.15.0-29-generic/kernel/drivers/watchdog/hpwdt.ko
/lib/modules/4.15.0-32-generic/kernel/drivers/watchdog/hpwdt.ko
/lib/modules/4.15.0-34-generic/kernel/drivers/watchdog/hpwdt.ko
/sbin/pam_extrausers_chkpwd
/sbin/unix_chkpwd
/snap/core/4917/bin/pwd
[...]
\end{screen}

Unele distribuții Linux folosesc comanda \cmd{slocate} în locul comenzii \cmd{locate}, care afișează doar fișierele din directoarele în care utilizatorul curent are drepturi de acces.

\subsubsection{Comanda find}
\label{sec:fs:find}

Pentru căutarea în ierarhia de directoare al fișierelor se folosește comanda \cmd{find}, comandă ce parcurge exhaustiv ierarhia de directoare. Comanda permite căutarea folosind diferite criterii, precum numele fișierului, utilizator, grup, tip, permisiuni, dimensiune, dată și altele. Exemple de opțiuni ale comenzii \cmd{find} pentru criterii de căutare:

\begin{itemize}
  \item \texttt{-name} - căutare după numele fișierelor
  \item \texttt{-type} - căutare după tipul intrării (fișier, director, legătură simbolică)
  \item \texttt{-size} - căutare după dimensiunea fișierelor
\end{itemize}

Mai jos avem câteva exemple de folosire a comenzii \cmd{find}:

\begin{itemize}
  \item în \labelindexref{Listing}{lst:fs:find-symlinks} căutăm în ierarhia \cmd{/usr/} toate legăturile simbolice
  \item în \labelindexref{Listing}{lst:fs:find-name} căutăm în ierarhia \cmd{/usr/} toate fișierele care au numele \texttt{stat}
  \item în \labelindexref{Listing}{lst:fs:find-size} obținem fișierele care au o dimensiune mai mare de \texttt{500KB}
\end{itemize}

\begin{screen}[caption={Afișarea linkurilor simbolice din ierarhia /usr/},label={lst:fs:find-symlinks}]
student@uso:~$ find /usr/ -type l
/usr/lib/pm-utils/sleep.d/95hdparm-apm
/usr/lib/libgjs.so.0
/usr/lib/bfd-plugins/liblto_plugin.so
/usr/lib/sudo/libsudo_util.so
/usr/lib/sudo/libsudo_util.so.0
/usr/lib/gold-ld/ld
/usr/lib/systemd/user/dbus-org.bluez.obex.service
/usr/lib/systemd/user/graphical-session.target.wants/update-notifier-release.path
/usr/lib/systemd/user/graphical-session.target.wants/update-notifier-crash.path
/usr/lib/systemd/user/graphical-session.target.wants/unicast-local-avahi.path
[...]
\end{screen}

\begin{screen}[caption={Afișarea fișierelor cu numele stat din ierarhia /usr/},label={lst:fs:find-name}]
student@uso:~$ find /usr -name stat
/usr/bin/stat
/usr/src/linux-headers-4.15.0-29-generic/include/config/f2fs/stat
/usr/src/linux-headers-4.15.0-32-generic/include/config/f2fs/stat
/usr/src/linux-headers-4.15.0-34-generic/include/config/f2fs/stat
\end{screen}

\begin{screen}[caption={Afișarea fișierelor cu o dimensiune mai mare de 500KB din ierarhia /usr/},label={lst:fs:find-size}]
student@uso:~$ find /usr/ -size +500k
/usr/lib/gnome-shell/gnome-shell-portal-helper
/usr/lib/gnome-shell/libgnome-shell.so
/usr/lib/p7zip/7zr
/usr/lib/xorg/modules/drivers/intel_drv.so
/usr/lib/xorg/Xorg
/usr/lib/debug/lib/x86_64-linux-gnu/libnsl-2.27.so
/usr/lib/debug/lib/x86_64-linux-gnu/libmvec-2.27.so
/usr/lib/debug/lib/x86_64-linux-gnu/ld-2.27.so
/usr/lib/debug/lib/x86_64-linux-gnu/libm-2.27.so
/usr/lib/debug/lib/x86_64-linux-gnu/libc-2.27.so
[...]
\end{screen}

\subsubsection{Căutarea comenzilor}
\label{sec:fs:cmd-search}

Uneori dorim să identificăm o comandă sau executabilul aferent unei comenzi. Pentru aceasta folosim comenzile \cmd{whereis}, \cmd{which} și \cmd{type}.

Comanda \cmd{whereis} este utilizată pentru căutarea locurilor corespunzătoare unei comenzi în sistemul de fișiere De exemplu, pentru a localiza comanda \cmd{ls}, folosim:

\begin{screen}
student@uso:~$ whereis ls
ls: /bin/ls /usr/share/man/man1/ls.1posix.gz /usr/share/man/man1/ls.1.gz
\end{screen}

Comanda afișează calea către executabil și către pagina de manual a comenzii.

Dacă dorim doar obținerea căii către executabilul aferent comenzii, folosim comanda \cmd{which}. De exemplu, comanda următoare afișează calea către executabilul aferent comenzii \cmd{chmod}:

\begin{screen}
student@uso:~$ which chmod
/bin/chmod
\end{screen}

Utilizarea comenzii \cmd{type} duce la determinarea modului de interpretare a altei comenzi, de exemplu comandă integrată în shell (numită și internă sau \textit{builtin}), comandă externă sau alias. Mai multe despre comenzi în shell, interne și externe, vor fi prezentate în \labelindexref{Capitolul}{chapter:cli}.

Un exemplu de comandă integrată in shell este comanda \cmd{cd} în vreme ce o comanda externă, care are un executabil asociat, este comanda \cmd{cat}, așa cum putem vedea în \labelindexref{Listing}{lst:fs:type}.

\begin{screen}[caption={Tipul unei comenzi},label={lst:fs:type}]
student@uso:~$ type cd
cd is a shell builtin
student@uso:~$ type cat
cat is /bin/cat
student@uso:~$ type ls
ls is aliased to `ls --color=auto'
\end{screen}

În cazul unui alias de comandă, comanda \cmd{type} va preciza că este un alias așa cum reiese din liniile 5 și 6 din \labelindexref{Listing}{lst:fs:type}.

\subsection{Arhivarea și dezarhivarea fișierelor}
\label{sec:fs:archive}

Prin procesul de arhivare, mai multe fișiere și directoare sunt strânse la un loc într-un fișier unic, realizându-se de obicei și reducerea dimensiunii (compresie). În general noțiunea de arhivare se referă doar la lipirea datelor într-un singur loc, în vreme ce compresia se referă la codificarea datelor pentru a reduce dimensiunea fișierului rezultat.

În cazul compresiei se creează un dicționar care conține secvențe de octeți care se repetă mai des și codificarea lor pe mai puțini octeți. Pe lângă dicționar, în fișierul rezultat este conținut și cuprinsul fișierelor. Fiind folosite referințele către dicționar a secvențelor lungi, se realizează astfel o economie de spațiu. Cu cât fișierele conțin mai multe date repetitive, cu atât dimensiunile fișierului comprimat rezultat scad.

Utilitare precum \cmd{zip} realizează atât arhivare cât și compresie; utilitarul \cmd{tar} realizează doar arhivare, iar utilitarul \cmd{gzip} realizează doar compresie; de obicei utilitarele \cmd{tar} și \cmd{gzip} sunt folosite la comun pentru a realiza și arhivarea și compresia.

Numele utilitarului \cmd{tar} este acronimul \textit{tape archiver}, provenind de la faptul că, la origine, rezultatul era transferat pe benzi magnetice. Fișierele \texttt{.tar} au în componență fișierele inițiale necomprimate precum și informațiile legate de modul lor de extragere (spre exemplu: de unde până unde se găsește un fișier în cadrul arhivei). Din această cauză fișierele \texttt{.tar} au o dimensiune mai mare decât suma dimensiunilor fișierelor care îl alcătuiesc.

\labelindexref{Listing}{lst:fs:tar} prezintă exemple de folosire ale comenzii \cmd{tar}.

\begin{screen}[caption={Folosirea comenzii tar},label={lst:fs:tar}]
student@uso:~$ tar cvf 01-fs.tar uso.git/labs/01-fs/
uso.git/labs/01-fs/
uso.git/labs/01-fs/wiki/
uso.git/labs/01-fs/wiki/basics.wiki
uso.git/labs/01-fs/wiki/concepts.wiki
uso.git/labs/01-fs/wiki/demo.wiki
[...]
student@uso:~$ tar tf 01-fs.tar
uso.git/labs/01-fs/
uso.git/labs/01-fs/wiki/
uso.git/labs/01-fs/wiki/basics.wiki
uso.git/labs/01-fs/wiki/concepts.wiki
uso.git/labs/01-fs/wiki/demo.wiki
[...]
student@uso:~$ cd /tmp/
student@uso:/tmp$ tar xf ~/01-fs.tar
student@uso:/tmp$ ls uso.git/labs/01-fs/
support  wiki
\end{screen}

Mai sus am creat o arhivă \file{.tar} (linia \texttt{1}), am listat conținutul ei (linia \texttt{8}) și apoi am dezarhivat-o în directorul \file{/tmp/} (liniile \texttt{15-16}).

Opțiunile comenzii \cmd{tar}, folosite mai sus, sunt:
\begin{itemize}
  \item \texttt{c} (pentru \textit{create}): pentru a crea arhiva
  \item \texttt{x} (pentru \textit{extract}): dezarhivează
  \item \texttt{t} (pentru \textit{list}): listează conținut
  \item \texttt{v} (pentru \textit{verbose}): arată ce se întâmplă
  \item \texttt{f nume\_arhiva.tar} (pentru \textit{file}): numele arhivei
\end{itemize}

\begin{note}[Observație]
\texttt{f} și \texttt{nume\_arhiva.tar} reprezintă un singur parametru – astfel, când folosim \texttt{f} pentru a indica un fișier, acesta trebuie să se afle ultimul în lista de parametri.
\end{note}

Cele mai folosite utilitare în Linux care realizează comprimarea unui fișier sunt:

\begin{itemize}
  \item \cmd{gzip}: are o viteză mai ridicată de compresie, dar o rată de mai scăzută (fișiere rezultat mai mari)
  \item \cmd{bzip2}: are viteză mai scăzută de compresie, dar o rată de compresie mai ridicată
\end{itemize}

Comanda \cmd{tar} poate să utilizeze oricare dintre programele de compresie de mai sus și se folosește de parametrul \texttt{z} pentru gzip și \texttt{j} pentru bzip2 ca în \labelindexref{Listing}{lst:fs:tar-zip}.

\begin{screen}[caption={Arhivarea cu compresie folosind tar},label={lst:fs:tar-zip}]
student@uso:~$ tar czf 01-fs.tar.gz uso.git/labs/01-fs/
student@uso:~$ tar cjf 01-fs.tar.bz2 uso.git/labs/01-fs/
student@uso:~$ file 01-fs.tar.*
01-fs.tar.bz2: bzip2 compressed data, block size = 900k
01-fs.tar.gz:  gzip compressed data, last modified: Sun Sep 30 17:02:19 2018, from Unix
\end{screen}

În \labelindexref{Listing}{lst:fs:tar-zip} am folosit, respectiv, opțiunea \texttt{z} (în cadrul opțiunii \texttt{czf}) pentru a comprima folosind \cmd{gzip} (linia \texttt{1}), și apoi opțiunea \texttt{j} (în cadrul opțiunii \texttt{cjf}) pentru a comprima folosind \cmd{bzip2} (linia \texttt{2}). Apoi am folosit comanda \cmd{file} pentru a verifica tipul fișierelor și am confirmat tipul de compresie aferent celor două fișiere rezultate (liniile \texttt{3-5}).

\subsection{Backup}
\label{sec:fs:backup}

Backupul este utilizat pentru a păstra într-un loc separat o copie a datelor, copie ce poate fi folosită pentru a le recupera în cazul în care, din diferite motive, suportul original nu mai poate fi folosit. Adesea omitem sau amânăm realizarea unei versiuni de backup a datelor, putând ajunge la pierderea informațiilor în situații de defecțiune. De aceea, în ultimii ani sunt foarte populare soluțiile de backup automat în Cloud. Astfel, utilizatorii pot folosi soluții precum Google Drive, Dropbox, Microsoft OneDrive pentru a sincroniza automat conținutul directoarelor în care lucrează cu un spațiu de stocare cloud. Dacă utilizatorul lucrează pe mai multe dispozitive (desktop, laptop, mobil etc.) poate fi configurată sincronizarea tuturor acestor dispozitive cu cloudul, facilitând astfel transferul documentelor.

Chiar dacă realizăm sincronizarea automată prin Cloud, este util să creăm și backupuri periodice pe alte suporturi fizice. De exemplu, în cazul în care datele noastre sunt afectate de erori grave, datorită malware sau ștergerii accidentale, aceste erori se pot propaga și în Cloud, dar versiunile salvate anterior pe suporturi fizice distincte vor fi protejate.

\labelindexref{Tabelul}{table:file-system-backup-cmd} prezintă câteva metode de backup și situațiile când sunt ele
potrivite.

\begin{table}[htb]
\begin{center}
  \begin{tabular}{ p{0.2\textwidth} p{0.7\textwidth} }
  \toprule
    \textbf{Metoda} & \textbf{Descriere} \\
  \midrule
    tar + gzip/bzip2 & Metodă foarte simplu de aplicat. Devine greu de folosit pentru dimensiuni mari de date. Permite compresia
    datelor. \\
  \midrule
    dd & Metoda simplu de folosit și independentă de sistemul de fișiere. Permite păstrarea intactă a structurii sistemului de fișiere. Inflexibilă când vine vorba de recuperarea datelor.  Utilă pentru cantități mari de date. \\
  \midrule
    rsync & E asemănătoare comenzii cp dar la care s-a adăugat suport de sincronizare intre mai multe computere. Permite replicarea structurii de fișiere (inclusiv permisiuni) între 2
    computere. \\
  \midrule
    rdiff-backup & Este un wrapper peste rsync. Adaugă suport pentru backupuri incrementale, adică: la un moment dat se realizează un backup complet pentru un director (asemănător rsync-ului); backup-urile incrementale salvează doar modificările ce s-au făcut de la ultimul backup pana în prezent, indiferent de tipul backup-ului; în acest fel se poate reveni la orice stare anterioara, în măsura în care s-a realizat cel puțin un backup incremental la acea stare. \\
  \bottomrule
  \end{tabular}
\end{center}
\caption{Metode pentru backup}
\label{table:file-system-backup-cmd}
\end{table}

Informații detaliate despre backupuri periodice folosind \cmd{rsync} vor fi prezentate în \labelindexref{Secțiunea}{sec:storage:backup:linux}.

\section{Redirectarea intrării sau ieșirii}
\label{sec:fs:redirect}

Așa cum veți întâlni în \labelindexref{Secțiunea}{sec:process:fd}, o aplicație care rulează folosește niște intrări speciale (standard); în folosirea acestor intrări și a altor fișiere folosește descriptori de fișiere.

Există 3 \textbf{fișiere speciale} utilizate de programele în execuție pentru a interacționa cu utilizatorii:

\begin{itemize}
  \item intrare standard (\textit{standard input}, \textit{stdin}): acesta reprezintă locul de unde se citesc datele de intrare de către program (de obicei tastatura)
  \item ieșire standard (\textit{standard output}, \textit{stdout}): acesta este fișierul în care se scriu datele de ieșire (de obicei este consola curentă)
  \item ieșire de eroare standard (\textit{standard error}, \textit{stderr}): în acest fișier se scriu mesajele de eroare de către program (de obicei tot în consola curentă)
\end{itemize}

Un descriptor de fișier reprezintă un indice asociat unui fișier deschis de o aplicație. Cele 3 fișiere speciale de mai sus au următorii descriptori de fișier:

\begin{itemize}
  \item \texttt{stdin} are descriptorul cu indexul 0
  \item \texttt{stdout} are descriptorul cu indexul 1
  \item \texttt{stderr} are descriptorul cu indexul 2
\end{itemize}

Restul fișierelor deschise de aplicații au un descriptor de fișier mai mare sau egal cu 3. În C/C++ există 3 variabile de tipul \texttt{FILE *} cu numele \texttt{stdin}, \texttt{stdout}, \texttt{stderr}. Ele au același rol ca cele descrise mai sus și sunt folosite ca orice alte variabilă de tip \texttt{FILE *}.

În unele situații, utilizatorul poate dori să modifice intrarea sau ieșirea pentru o aplicație. De exemplu, utilizatorul își poate dori ca în loc să obțină datele de intrare de la tastatură pentru un program, să le obțină dintr-un fișier. Aceste operații se pot realiza doar la nivelul descriptorilor. În shell sunt permise comenzi cu o sintaxă specială asupra descriptorilor standard modificați; pot fi întâlnite cazurile de redirectare din \labelindexref{Tabelul}{table:fs:redirect}.

\begin{table}[htb]
\begin{center}
  \begin{tabular}{ p{0.2\textwidth} p{0.2\textwidth} p{0.5\textwidth}}
  \toprule
    \textbf{Sursă} & \textbf{Destinație} & \textbf{Exemplu comandă} \\
  \midrule
    intrare (\textit{stdin}) & Fișier & \cmd{./program $<$ fișier\_intrare} \\
  \midrule
    ieșire (\textit{stdout}) & Fișier & \cmd{./program $>$ fișier\_ieșire} \\
  \midrule
    eroare (\textit{stderr}) & Fișier & \cmd{./program 2$>$ fișier\_erori} \\
  \midrule
    eroare (\textit{stderr}) & iesire (stdout) & \cmd{./program 2$>$\&1} \\
  \midrule
    eroare \& ieșire & Fișier & \cmd{./program $>$ fișier\_ieșire\_și\_erori 2$>$\&1} \\
  \bottomrule
  \end{tabular}
\end{center}
\caption{Metode de redirectare}
\label{table:fs:redirect}
\end{table}

Pentru a redirecta ieșirea (către exteriorul programului) se folosește caracterul \texttt{$>$} (semnul \textit{mai mare}), în timp ce pentru a redirecta intrarea se folosește caracterul \texttt{$<$} (semnul \textit{mai mic}) (către program), iar pentru redirectarea ieșirii de erori se folosește descriptorul \texttt{2} de fișier urmat de caracterul \texttt{$>$}.

Sintaxa \texttt{\&1} se folosește atunci când se dorește redirectarea către ieșirea standard (\textit{stdout}), astfel încât construcția \texttt{2$>$\&1} redirectează ieșirea de eroare standard către ieșirea standard. Astfel, dacă dorim redirectarea ieșirii de erori și a ieșirii standard către un fișier trebuie să redirectăm mai întâi ieșirea de erori către stdout (\texttt{2$>$\&1}) și apoi să redirectăm ieșirea standard într-un fișier (\file{fișier\_erori\_și\_ieșiri}).

\labelindexref{Listing}{lst:fs:redirect-stdin} conține redirectarea intrării standard comenzii \cmd{mail} din conținutul fișierului \file{message.txt}. Utilizatorului \texttt{gabriel} i se va trimite un email cu informațiile din fișier.

\begin{screen}[caption={Redirectarea intrării standard},label={lst:fs:redirect-stdin}]
student@uso:~$ mail gabriel < message.txt
\end{screen}

Similar, \labelindexref{Listing}{lst:fs:redirect-stdout} conține comanda care va scrie în fișierul \file{listare} toate fișierele și directoarele ce se află în directorul curent.

\begin{screen}[caption={Reidrectarea ieșirii standard},label={lst:fs:redirect-stdout}]
student@uso:~$ ls > listare
student@uso:~$ cat listare
01-fs.tar
01-fs.tar.bz2
01-fs.tar.gz
Desktop
Documents
Downloads
Music
Pictures
Public
Templates
Videos
examples.desktop
games
listare
uso.git
vm-actions-log.txt
\end{screen}

Pentru a adăuga la sfârșitul fișierului rezultatul unei comenzi folosim operatorul $>>$ ca în \labelindexref{Listing}{lst:fs:redirect-append}.

\begin{screen}[caption={Redirectarea cu adăugare (append)},label={lst:fs:redirect-append}]
student@uso:~$ date >> listare
student@uso:~$ cat listare
[...]
vm-actions-log.txt
duminica 30 septembrie 2018, 20:17:50 +0300
\end{screen}

În \labelindexref{Listing}{lst:fs:redirect-stderr} este redirectată ieșirea de eroare standard. Comanda de la linia 1 încearcă să copieze un fișier fără a spune unde dorește să-l
copieze, comandă ce va genera o eroare care va fi redirectată în fișierul \file{errors.out}.

\begin{screen}[caption={Redirectarea ieșirii de eroare standard},label={lst:fs:redirect-stderr}]
student@uso:~$ cp listare 2> errors.out
student@uso:~$ cat errors.out
cp: missing destination file operand after 'listare'
Try 'cp --help' for more information.
\end{screen}

Putem redirecta și ieșirea standard și ieșirea de eraore standard în același fișier. În \labelindexref{Listing}{lst:fs:redirect-both}, atât ieșirea standard cât și ieșirea de eroare standard ale comenzii \cmd{strace ls} de pe linia 1 vor fi redirectate în fișierul \file{strace-all.out}.

\begin{screen}[caption={Redirectarea ieșirii standard și ieșirii de eroare standard în același fișier},label={lst:fs:redirect-both}]
student@uso:~$ strace ls > strace-all.out 2>&1
student@uso:~$ cat strace-all.out
execve("/bin/ls", ["ls"], 0x7ffd95189350 /* 36 vars */) = 0
brk(NULL)                               = 0x5578b9d96000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=91329, ...}) = 0
[...]
\end{screen}

\labelindexref{Tabelul}{table:file-system-redirect-special} prezintă câteva redirectări folosind fișiere speciale.

\begin{table}[htb]
  {\scriptsize
\begin{center}
  \begin{tabular}{ p{0.4\textwidth} p{0.5\textwidth}}
  \toprule
    \textbf{Comanda} & \textbf{Efect} \\
  \midrule
    \cmd{./program 2$>$ /dev/null} & mesajele de la ieșirea de eroare standard nu sunt afișate \\
  \midrule
    \cmd{./program $>$ /dev/null 2$>$\&1} & nici un mesaj nu este afișat \\
  \midrule
    \cmd{$>$ new\_file} & creează un fișier gol cu numele \file{new\_file} \\
  \midrule
    \cmd{cat /dev/null $>$ new\_file} & creează un fișier cu același conținut ca \file{/dev/null}, adică un fișier gol, indentic ca mai sus \\
  \bottomrule
  \end{tabular}
\end{center}
  }
\caption{Redirectări folosind fișiere speciale}
\label{table:file-system-redirect-special}
\end{table}

Detalii despre internele redirectării și ce se întâmplă la nivelul unei aplicații găsiți în \labelindexref{Secțiunea}{sec:process:redirect}.

\section{Tipuri de sisteme de fișiere}
\label{sec:fs:types}

În timp au apărut mai multe tipuri de sisteme de fișiere, majoritatea dezvoltându-se în mediul open-source. Utilizatorii au opțiunea de a alege sistemul de fișiere preferat cu care doresc să lucreze, mai ales în cazul în care folosesc partiții multiple pentru mai multe sisteme de operare.

Pentru mai multe informații despre crearea, montarea și repararea unui sistem de fișiere, precum și lucrul cu partiții, citiți \labelindexref{Capitolul}{chapter:storage}. În \labelindexref{Tabelul}{table:fs:os-fs} de mai jos se găsesc unele dintre cele mai importante sisteme de fișiere utilizate în prezent, alături de sistemele de operare în care operează.

\begin{table}[htb]
\begin{center}
  \begin{tabular}{ p{0.18\textwidth} p{0.23\textwidth} p{0.23\textwidth} p{0.23\textwidth} }
  \toprule
    \textbf{SO} & \textbf{Windows} & \textbf{Linux} & \textbf{Mac OS} \\
    \textbf{Sistem fișiere} & & & \\
  \midrule
    FAT32 & Nativ & Nativ & Nativ \\
  \midrule
    NTFS & Nativ (dupa WinNT) & prin ntfs-3g & prin ntfs-3g \\
  \midrule
    Ext2/Ext3/Ext4 & Driver third-party & Nativ & - \\
  \midrule
    HFS+ & - & Nativ & Nativ \\
  \midrule
    APFS & - & - & Nativ \\
  \midrule
    ISO9660 & Nativ & Nativ & Nativ \\
  \midrule
    UDF & Nativ & Nativ & Nativ \\
  \bottomrule
  \end{tabular}
\end{center}
\caption{Sisteme de operare și sisteme de fișiere}
\label{table:fs:os-fs}
\end{table}

Termenul ,,nativ'' semnifică faptul că suportul este oferit de driverele ce însoțesc sistemul de operare.

Sistemele de fișiere pot fi clasificate după locul în care datele sunt stocate. \labelindexref{Tabelul}{table:fs:fs-storage} prezintă succint această clasificare.

\begin{table}[htb]
\begin{center}
  \begin{tabular}{ p{0.25\textwidth} p{0.25\textwidth} p{0.4\textwidth} }
  \toprule
    \textbf{Tip} & \textbf{Exemplu} & \textbf{Descriere} \\
  \midrule
    sisteme de fișiere cu suport fizic &  FAT32, NTFS, Ext4, APFS & se regăsesc de obicei pe un mediu de stocare \\
  \midrule
    sisteme de fișiere virtuale & procfs, devfs, SSHFS & conțin fișiere/date generate de SO (informații despre sistem) sau de o altă componentă software (alte surse) \\
  \midrule
    sisteme de fișiere pentru rețea & NFS, SMB & utilizate pentru accesul la fișiere aflate în rețea \\
  \bottomrule
  \end{tabular}
\end{center}
\caption{Clasificarea sistemelor de fișiere după suportul datelor}
\label{table:fs:fs-storage}
\end{table}

Sistemele de fișiere virtuale (precum \texttt{procfs}) sunt sisteme care nu au suport fizic pe disc. Accesul prin comenzi la aceste sisteme de fișiere duce de obicei la date care se găsesc în memorie. Despre sistemul de fișiere \texttt{procfs} vor fi prezentate detalii în \labelindexref{Secțiunea}{sec:process:proc}.

\subsection{Integritatea datelor}
\label{sec:fs:integrity}

Cărțile din bibliotecă se îngălbenesc, caietele se șifonează și scrisul își pierde conturul. Fișierele digitale se pot și ele degrada, datorită unor erori.  Sistemele de fișiere au un rol vital în asigurarea integrității datelor (\textit{data integrity}), adică în prevenirea, detectarea și remedierea coruperii datelor. Coruperea datelor (\textit{data corruption}) se referă la degradarea neintenționată a datelor datorită erorilor umane, erorilor de transmisie, defecțiunilor mediului fizic de stocare sau a diferitelor deficiențe în procesare. Securizarea datelor (\textit{data security}) se referă la prevenirea atacurilor intenționate asupra datelor și de asemenea necesită sprijinul sistemului de fișiere.

Un exemplu de metodă prin care sistemele de fișiere pot asigura integritatea datelor se referă la calcularea unei sume de control (\textit{checksum}).  Pentru un anumit set de date, o sumă de control este un număr care descrie pe scurt acel set, diferențiindu-l suficient de mult de un set foarte similar dar un pic diferit. De exemplu, o sumă de control poate consta efectiv în însumarea valorilor numerice asociate cu caracterele respective într-un cod, precum valorile lor numerice din codul ASCII. Dacă se modifică o literă din greșeală, suma va diferi și eroarea va fi detectată.

Sistemul de fișiere trebuie să fie capabil să păstreze integritatea datelor și în situația unui eșec (\textit{failure}). În cele mai multe cazuri această funcționalitate se implementează prin \textbf{jurnalizare}, care permite și aducerea sistemului la o stare anterioară eșecului. Prin această activitate se creează un jurnal unde sunt păstrate toate modificările efectuate asupra unui sistem de fișiere, fiecare dintre aceste modificări fiind mai întâi scrisă în jurnal și apoi realizată (modificările putând apărea în mai multe locuri din sistemul de fișiere).

Operațiile din jurnal sunt executate la diferite intervale de timp de către driver-ul sistemului pentru actualizarea stării discului. După ce toate modificările asociate unei operații sunt executate, aceasta se șterge din jurnal, astfel că, la apariția unui eșec (cum ar fi întreruperile de curent, defecțiunile fizice ale dispozitivului etc.), vor putea fi executate operațiile care au fost începute, dar s-au întrerupt, deoarece ele sunt încă prezente în jurnal, urmând să fie reexecutate în întregime.

\subsection{Alegerea unui sistem de fișiere}
\label{sec:fs:choose}

Atunci când alegem un sistem de fișiere, criteriile cele mai căutate sunt:

\begin{itemize}
  \item disponibilitatea: dacă sistemul respectiv poate fi folosit în mai multe sisteme de operare, sau doar în unul singur;
  \item gradul de siguranță: dacă asigură jurnalizare sau nu -- majoritatea sistemelor din prezent folosesc jurnalizarea, alte măsuri luate pentru a permite integritatea datelor;
  \item restricții speciale date de modul în care datele din sistemul de fișiere sunt organizate;de exemplu: FAT32 folosește doar 32 biți pentru stocarea dimensiunii unui fișier, deci dimensiunea maximă a unui fișier este 4GB (mai puțin decât o imagine de DVD, fapt ce îl face nepractic pentru o parte din aplicațiile multimedia)
  \item optimizări de performanță, ce sunt realizate în funcție ori de tipul suportului de stocare, ori de dimensiunea fișierelor etc.
\end{itemize}

\labelindexref{Tabelul}{table:fs:details} realizează o analiză sumară a caracteristicilor sistemelor de fișiere. Unitatea TiB reprezintă un tebibyte, adică $2^{40}$ octeți, iar un EiB reprezintă un exbibyte, adică $2^{60}$ octeți.

\begin{table}[htb]
  \scriptsize
\begin{center}
  \begin{tabular}{ p{0.07\textwidth} p{0.15\textwidth} p{0.2\textwidth} p{0.07\textwidth} p{0.35\textwidth} }
  \toprule
    \textbf{Nume} & \textbf{Sisteme de operare} &
    \textbf{Dimensiune maximă fișier} & \textbf{Jurnalizare} &
    \textbf{Observații} \\
  \midrule
    FAT32 & Windows / Linux / Mac OS & 4 GB & nu & Cel mai folosit sistem de fișiere - întâlnit în mod special pe USB stick-uri, fără drepturi de acces; Windows-ul limitează la creare dimensiunea unei partiții la 32GB, dar poate citi partiții mai mari realizate și formatate cu aplicații third-party folosit pentru a asigura compatibilitatea cu dispozitive sau sisteme mai vechi \\
  \midrule
    NTFS & Windows / Linux / Mac OS & 16TiB & da & Singurul sistem de fișiere pentru Windows recomandat de Microsoft. Singurul sistem de fișiere pentru Windows cu securitate. \\
  \midrule
    Ext2/Ext3 & Linux / Windows & 16GiB - 64TiB & ext2-nu ext3-da & Sistemul de fișiere considerat cel mai stabil datorită unei istorii de dezvoltare foarte lungi; ext3 e compatibil cu versiunea anterioară ext2, aduce jurnalizare față de ext2 \\
  \midrule
    Ext4 & Linux / Windows / MacOS & 16TiB & da & Succesorul lui Ext3, îmbunătățind performanța, stabilitatea și capacitatea de stocare. Este adecvat și pentru stocarea datelor critice, datorită preciziei ridicate ale marcajelor temporale. \\
  \midrule
    HFS+ & Mac OS / Linux & 16 EiB & da* & * în Linux, HFS+ are suport fără jurnalizare \\
  \midrule
    APFS & MacOS, iOS & 8 EiB & da & Este optimizat pentru dispozitivele de stocare tip flash și solid drive, și pune accentul pe criptare. \\
  \midrule
    ISO9660 & Win / Linux / Mac OS & În funcție de implementare & nu & Sistem de fișiere utilizat în principal pe CD-uri, organizare internă concepută pentru ca datele să fie citibile ușor \\
  \midrule
    UDF & Win / Linux / Mac OS & 16 EiB & da & Sistem de fișiere utilizat în principal pe mediile optice, cu suport atât pentru scriere cât și pentru citire \\
  \bottomrule
  \end{tabular}
\end{center}
\caption{Caracteristici ale sistemelor de fișiere mai cunoscute}
\label{table:fs:details}
\end{table}

\section{Anexă: Comenzi pentru lucrul cu fișiere în Windows}
\label{sec:fs:win-cmd}

\labelindexref{Tabelul}{table:fs:compare-lin-win-cmd} prezintă comenzile echivalente în Windows pentru operațiile de lucru cu sistemul de fișiere. Acestea pot fi folosite în prompt-urile Windows precum PowerShell sau Command Prompt.

\begin{table}[htb]
\begin{center}
  \begin{tabular}{ p{0.2\textwidth} p{0.2\textwidth} p{0.4\textwidth} }
  \toprule
    \textbf{Comanda Linux} & \textbf{Comanda Windows} & \textbf{Descriere} \\
  \midrule
    \cmd{comanda -{}-help} & \cmd{comanda /?} & afișează informații despre comandă \\
  \midrule
    \cmd{cd} & \cmd{cd} & schimbă directorul curent \\
  \midrule
    \cmd{pwd} & \cmd{chdir} & afișează directorul curent \\
  \midrule
    \cmd{clear} & \cmd{cls} & șterge ecranul consolei curente \\
  \midrule
    \cmd{cp} & \cmd{copy} & copiază un fișier \\
  \midrule
    \cmd{rm} & \cmd{del} & șterge un fișier \\
  \midrule
    \cmd{ls} & \cmd{dir} & afișează conținutul directorului curent \\
  \midrule
    \cmd{vim} & \cmd{edit} & editează un fișier text \\
  \midrule
    \cmd{exit} & \cmd{exit} & închide shellul curent \\
  \midrule
    \cmd{diff} & \cmd{fc} & compară două fișiere și afișează diferențele între ele \\
  \midrule
    \cmd{find} & \cmd{find} & caută fișiere \\
  \midrule
    \cmd{mkfs (mke2fs)} & \cmd{format} & formatează un disc \\
  \midrule
    \cmd{free} & \cmd{mem} & afișează informații despre memoria liberă și cea ocupată \\
  \midrule
    \cmd{mkdir} & \cmd{mkdir} & creează un nou director \\
  \midrule
    \cmd{mv} & \cmd{move} & mută un fișier \\
  \midrule
    \cmd{mv} & \cmd{ren} & redenumește un fișier \\
  \midrule
    \cmd{date} & \cmd{time} & afișează ora sistemului \\
  \midrule
    \cmd{diff} & \cmd{fc} & afișează diferențele dintre două fișiere \\
  \bottomrule
  \end{tabular}
\end{center}
\caption{Echivalențe comenzi Linux și Windows}
\label{table:fs:compare-lin-win-cmd}
\end{table}

\section{Sumar}
\label{sec:fs:summary}

Fișierele reprezintă unele dintre componentele sistemului de operare cele mai aproapiate de utilizator.
Utilizatorul folosește fișierele pentru a reține informații proprii sau pentru că acestea sunt folosite de aplicații.

Fișierele sunt organizate într-o structură ierarhică, pentru acces rapid.
Structura se numește sistem de fișiere.
În vârful ierarhiei sistemului de fișiere se găsește directorul rădăcină.
Un fișier sau director este identificat printr-o cale în sistemul de fișiere.
Calea absolută pornește de la directorul rădăcină.

Sistemul de operare oferă utilitare pentru realizarea operațiilor uzuale cu fișiere: creare, ștergere, redenumire, căutare, afișare conținut, modificare conținut.
Aceste operații sunt comune tuturor sistemelor de operare și sistemelor de fișiere.
